<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>calculator</title>
    </head>
    <style>
        body :focus {
            outline: none;
        }

        #input {
            padding-left: 5px;
            background: #555555;
            color: #ffffff;
        }

        .code div:before {
            content: "|";
            width: 20px;
        }
    </style>
    <body style="font-family: 'Source Code Pro', monospace; margin: 0px">
        <div style="display: absolute; width: 100%; height: 100%">
            <div id="input" contenteditable="plaintext-only"></div>
            <pre id="output" style="padding: 5px">yo</pre>
        </div>
    </body>
    <script>
        const debug = true;

        // ---- evaluating the AST
        // This is before the parsing code, because the parser depends on some of the structures and stuff defined here.

        const VT_NUMBER = debug ? "VT_NUMBER" : 0;
        const VT_ERROR = debug ? "VT_ERROR" : 1;

        function makeErr(info) {
            return {
                vt: VT_ERROR,
                v: info
            };
        }

        function vtToString(vt) {
            switch (vt) {
                case VT_NUMBER:
                    return "VT_NUMBER";
                case VT_ERROR:
                    return "VT_ERROR";
            }
            return "unknown type " + vt;
        }

        function evaluateNumber(x) {
            return makeNumber(x.value);
        }

        function makeNumber(n) {
            return {
                vt: VT_NUMBER,
                val: parseFloat(n)
            };
        }

        const builtInConstantsMap = {
            // the 'pi' constant
            PI: makeNumber("3.14159265358979"),
            // the 'e' constant
            E: makeNumber("2.718281828459045"),
            // golden ratio
            PHI: makeNumber("1.618033988749")
        };
        const builtInConstants = Object.keys(builtInConstantsMap);

        function evaluateBuiltinConstant(x) {
            const func = builtInConstantsMap[x.value];
            if (!func) {
                return makeErr("Unknown builtin constant " + x.value);
            }

            return func;
        }

        // the function operator(T1, t2) can be found by doing applicatorMatrix[t1][t2][operator].
        const binOpMatrix = {
            [VT_NUMBER]: {
                [VT_NUMBER]: {
                    "+": (a, b) => ({ vt: a.vt, val: a.val + b.val }),
                    "-": (a, b) => ({ vt: a.vt, val: a.val - b.val }),
                    "*": (a, b) => ({ vt: a.vt, val: a.val * b.val }),
                    "/": (a, b) => ({ vt: a.vt, val: a.val / b.val }),
                    "%": (a, b) => ({ vt: a.vt, val: a.val % b.val }),
                    "^": (a, b) => ({ vt: a.vt, val: Math.pow(a.val, b.val) })
                }
            }
        };

        function applyOperator(val, x, op) {
            const val2 = evaluateExpression(x);
            const t1 = val.vt;
            const t2 = val2.vt;

            const applicator = binOpMatrix[t1][t2][op.value];
            if (!applicator) {
                return makeErr(
                    `the operator ${op.value} doesn't have a mapping from ${vtToString(t1)} -> ${vtToString(
                        t2
                    )}`
                );
            }

            return applicator(val, val2);
        }

        function evaluateChain(x) {
            let val = evaluateExpression(x.terms[0]);
            for (let i = 1; i < x.terms.length; i++) {
                val = applyOperator(val, x.terms[i], x.ops[i - 1]);
            }
            return val;
        }

        const unaryOpsMap = {
            [VT_NUMBER]: {
                "+": (x) => x,
                "-": (x) => ({ vt: x.vt, val: -x.val })
            }
        };
        const unaryOps = []
        for(const typeKey in unaryOpsMap) {
            const opList = unaryOpsMap[typeKey];
            for (const op in opList) {
                unaryOps.push(op);
            }
        }

        function evaluateUnaryOp(x) {
            const val = evaluateExpression(x.expr);
            const func = unaryOpsMap[val.vt][x.op.value];
            if (!func) {
                return makeErr(`unary op ${x.op.value} can't be used on ${vtToString(val.vt)}`);
            }

            return func(val);
        }

        function evaluateExpression(x) {
            const type = x.t;

            switch (type) {
                case T_NUMBER:
                    return evaluateNumber(x);
                case T_BUILTIN_CONSTANT:
                    return evaluateBuiltinConstant(x);
                case T_EXPR:
                case T_TERM:
                    return evaluateChain(x);
                case T_UNARY_OP:
                    return evaluateUnaryOp(x);
                default:
                    return "Unknown ast node type";
            }
        }

        function evaluateProgram(program, text) {
            if (program.error) {
                return program.error;
            }

            return program.expressions.map((x) => evaluateExpression(x));
        }

        // ---- parser

        const T_EXPR = debug ? "T_EXPR" : 0;
        const T_NUMBER = debug ? "T_NUMBER" : 1;
        const T_OP_EXPR = debug ? "T_OP_EXPR" : 2;
        const T_OP_TERM = debug ? "T_OP_TERM" : 3;
        const T_TERM = debug ? "T_TERM" : 4;
        const T_BUILTIN_CONSTANT = debug ? "T_BUILTIN_CONSTANT" : 5;
        const T_UNARY_OP = debug ? "T_UNARY_OP" : 6;

        // Thankyou Trevor bro https://stackoverflow.com/questions/1496826/check-if-a-single-character-is-a-whitespace
        function isWhitespace(c) {
            return (
                c === " " ||
                c === "\n" ||
                c === "\t" ||
                c === "\r" ||
                c === "\f" ||
                c === "\v" ||
                c === "\u00a0" ||
                c === "\u1680" ||
                c === "\u2000" ||
                c === "\u200a" ||
                c === "\u2028" ||
                c === "\u2029" ||
                c === "\u202f" ||
                c === "\u205f" ||
                c === "\u3000" ||
                c === "\ufeff"
            );
        }

        function isDigit(c) {
            return (
                c === "1" ||
                c === "2" ||
                c === "3" ||
                c === "4" ||
                c === "5" ||
                c === "6" ||
                c === "7" ||
                c === "8" ||
                c === "9" ||
                c === "0"
            );
        }

        function advanceWhileWhitespace(text, pos) {
            while (pos < text.length && isWhitespace(text[pos])) pos++;
            return pos;
        }

        // parses one of some array possible delimiters. oneOfWhat is an array of possible strings
        function parseOneOf(text, ctx, lines, possibleDelimiters, type) {
            const pos = advanceWhileWhitespace(text, ctx.pos);

            for (let i in possibleDelimiters) {
                const end = pos + possibleDelimiters[i].length;
                if (end > text.length) {
                    continue;
                }

                if (text.substring(pos, end) === possibleDelimiters[i]) {
                    lines.push({
                        t: type,
                        start: pos,
                        end: end,
                        value: text.substring(pos, end)
                    });

                    ctx.pos = end;
                    return true;
                }
            }

            return false;
        }

        // operators with the same precedence as addition
        function parseOpExpr(text, ctx, ops) {
            return parseOneOf(text, ctx, ops, ["+", "-"], T_OP_EXPR);
        }

        // one of *, /, %
        function parseOpTerm(text, ctx, ops) {
            return parseOneOf(text, ctx, ops, ["*", "/", "%", "^"], T_OP_TERM);
        }

        // operators with the same precedence as multiplication
        function parseNumber(text, ctx, terms) {
            const start = advanceWhileWhitespace(text, ctx.pos);
            let pos = start;
            let foundDecimal = false;
            while (pos < text.length && (isDigit(text[pos]) || (!foundDecimal && text[pos] === "."))) {
                if (text[pos] === ".") {
                    foundDecimal = true;
                }

                pos++;
            }

            if (start === pos) {
                return false;
            }

            terms.push({
                t: T_NUMBER,
                start: start,
                end: pos,
                value: text.substring(start, pos)
            });
            ctx.pos = pos;
            return true;
        }

        // Parses a series of terms like <term> (<operator> <term>)*
        // the parsers for term and operator can be specified as functions
        function parseChain(text, ctx, lines, type, termParser, opParser) {
            const terms = [];
            const ops = [];

            let start = ctx.pos;

            if (!termParser(text, ctx, terms)) {
                return false;
            }

            while (opParser(text, ctx, ops)) {
                if (!termParser(text, ctx, terms)) {
                    // remove the last operator we parsed, we shouldn't have
                    const op = ops.pop();

                    // reset end
                    ctx.pos = terms[terms.length - 1].end;
                    break;
                }
            }

            if (terms.length === 1) {
                // the tree becomes unmanageably large if we don't unwrap nodes like this
                lines.push(terms[0]);
            } else {
                lines.push({
                    t: type,
                    start: start,
                    end: ctx.pos,
                    terms: terms,
                    ops: ops
                });
            }

            return true;
        }

        function parseExpressionGroup(text, ctx, lines) {
            const start = advanceWhileWhitespace(text, ctx.pos);

            if (text[start] === "(") {
                ctx.pos = start + 1;
                if (parseExpression(text, ctx, lines)) {
                    ctx.pos = advanceWhileWhitespace(text, ctx.pos);
                    if (text[ctx.pos] === ")") {
                        lines[lines.length - 1].start = start;
                        lines[lines.length - 1].end++;
                        ctx.pos++;
                        return true;
                    }
                }
            }
            return false;
        }

        function parseVariable(text, ctx, lines) {
            return parseOneOf(text, ctx, lines, builtInConstants, T_BUILTIN_CONSTANT);
        }

        function parseUnaryOp(text, ctx, lines) {
            const op = [];
            const expr = [];
            const unaryOps = ["+", "-"];

            const start = advanceWhileWhitespace(text, ctx.pos);

            ctx.pos = start;
            if (!parseOneOf(text, ctx, op, unaryOps, T_UNARY_OP)) {
                return false;
            }

            ctx.pos = advanceWhileWhitespace(text, ctx.pos);
            if (!parseExpression(text, ctx, expr)) {
                return false;
            }

            lines.push({
                t: T_UNARY_OP,
                start: start,
                end: ctx.pos,
                op: op[0],
                expr: expr[0]
            });
            return true;
        }

        function parseThing(text, ctx, lines) {
            const start = advanceWhileWhitespace(text, ctx.pos);

            ctx.pos = start;
            if (parseExpressionGroup(text, ctx, lines)) return true;

            ctx.pos = start;
            if (parseUnaryOp(text, ctx, lines)) return true;

            ctx.pos = start;
            if (parseVariable(text, ctx, lines)) return true;

            ctx.pos = start;
            if (parseNumber(text, ctx, lines)) return true;

            return false;
        }

        function parseTerm(text, ctx, lines) {
            return parseChain(text, ctx, lines, T_TERM, parseThing, parseOpTerm);
        }

        function parseExpression(text, ctx, lines) {
            return parseChain(text, ctx, lines, T_EXPR, parseTerm, parseOpExpr);
        }

        function parseExpressionList(text, ctx, lines) {
            const start = ctx.pos;

            while (parseExpression(text, ctx, lines)) {}

            return start !== ctx.pos;
        }

        // return an AST-like thing
        function parseProgram(text) {
            const ctx = { pos: 0 };
            const lines = [];

            while (parseExpressionList(text, ctx, lines)) {}
            ctx.pos = advanceWhileWhitespace(text, ctx.pos);

            const root = {
                expressions: lines,
                error: null
            };

            if (ctx.pos !== text.length) {
                const lines = text.substring(0, ctx.pos).split("\n");
                const linePos = ctx.pos - lines.lastIndexOf("\n");
                let contextText = text.substring(ctx.pos);
                if (contextText.length > 50) {
                    contextText = contextText.substring(0, 50) + "...";
                }
                root.error = `Couldn't read line ${lines.length} pos ${linePos}: "${contextText}"`;
            }

            return root;
        }

        function debugPrintProgram(ast, text) {
            const dfs = (node) => {
                if (typeof node === "string") {
                    return;
                }

                if (node === null || node === undefined) {
                    return "undefined";
                }

                if (typeof node.start === "number" && typeof node.end === "number") {
                    node.text = text.substring(node.start, node.end);
                    // node.val = evaluateProgram(node.text);
                    delete node.start;
                    delete node.end;
                }

                for (const k of Object.keys(node)) {
                    dfs(node[k]);
                }
            };

            dfs(ast);
            return JSON.stringify(ast, null, 4);
        }

        // ---- actually using the parser from here on

        const input = document.getElementById("input");

        input.addEventListener("input", () => {
            rerender(input.innerText);
        });

        function recompile(text) {
            const ast = parseProgram(text);

            const outputAst = debugPrintProgram(ast, text);

            const outputValue = evaluateProgram(ast, text);
            for (const i in outputValue) {
                outputValue[i] = JSON.stringify(outputValue[i], null, 4);
            }

            return outputValue + "\n\n" + outputAst;
        }

        function rerender(text) {
            document.getElementById("output").innerText = recompile(text);
        }

        input.innerText = "2 ^ 2";
        rerender(input.innerText);
    </script>
</html>
