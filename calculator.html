<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>calculator</title>
    </head>
    <!-- // ---- styles -->
    <style>
        *[hidden] {
            display: none !important;
        }

        body :focus {
            outline: none;
        }

        textarea {
            border: none;
            overflow: hidden;
            outline: none;

            margin: 0px;

            -webkit-box-shadow: none;
            -moz-box-shadow: none;
            box-shadow: none;

            resize: none; /*remove the resize handle on the bottom right*/
        }

        #input {
            padding-left: 5px;
            background: #000000;
            color: #ffffff;
            font-size: 1.2rem;
            line-height: 1.2rem;
            -moz-tab-size: 4;
            tab-size: 4;
        }
        #line-numbers {
            font-size: 1.2rem;
            line-height: 1.2rem;
            color: #aaaaaa;
            background: #000000;
            outline: none;
            border-right: 1px solid #aaaaaa;
        }

        .code div:before {
            content: "|";
            width: 20px;
        }

        .error {
            color: #ff0000;
        }

        th,
        td {
            outline: black solid 1px;
        }

        #testcases button {
            margin: 5px;
            display: block;
        }

        pre {
            margin: 0px;
        }
    </style>
    <body style="font-family: 'Source Code Pro', monospace; margin: 0px">
        <div style="padding: 10px" class="not-zen">
            <h2>Calculator</h2>

            <div style="margin-top: 20px">
                <!-- Not intended to be an actual calculator. It is practice for creating a parser to making a
                programming language that I have been thinking about for a while now. This won't be the actual language, nor
                will it be complete, but I will try to add some cool features. I don't intend to spend any
                more than around 4 days on this site. -->
                Type something into the box below. Or, click on some of the buttons in the table for examples.
                This is currently more of a tech demo than a polished and working product, I am currently at
                the stage where I am sketching out some ideas and seeing how viable this idea is before
                actually working on it seriously with efficient algorithms, or in a different language like
                C++ or Rust.
            </div>
        </div>
        <div>
            <!-- <div style="display: flex; flex-direction: row;">
                <div id="output" style="padding: 5px; white-space: pre; flex: 1; text-align:right;"></div>
                <div id="input" contenteditable="plaintext-only" style="padding: 5px; white-space: pre; min-height: 60px; flex: 1;"></div>
            </div> -->
            <div style="display: flex; flex-direction: row">
                <div id="line-numbers" style="padding: 5px; white-space: pre"></div>
                <textarea
                    id="input"
                    contenteditable="plaintext-only"
                    style="padding: 5px; white-space: pre; min-height: 60px; flex: 1"
                ></textarea>
            </div>
            <div id="output" style="padding: 5px; white-space: pre"></div>

            <div class="not-zen" style="margin-top: 50px; padding: 10px">
                <button id="zen-mode" style="width: unset">Remove clutter</button>
            </div>
        </div>
        <div style="padding: 10px" class="not-zen">
            <h4 title="these are really test cases">Debugging</h4>
            <input type="checkbox" id="show-ast-checkbox" />
            <label for="show-ast-checkbox">Show AST object</label><br />
            <pre id="ast-output" style="padding: 5px"></pre>
            <input type="checkbox" id="show-result-checkbox" />
            <label for="show-result-checkbox">Show result object</label><br />
            <pre id="result-output" style="padding: 5px"></pre>
        </div>
        <div style="padding: 10px" class="not-zen">
            <div style="margin-top: 20px">
                <h4 title="these are really test cases">Examples</h4>
                <table id="testcases" style="width: 100%"></table>
            </div>
        </div>
    </body>
    <script>
        const debug = true;
        // const debug = false;

        // ---- evaluating the AST
        // This is before the parsing code, because the parser depends on some of the structures and stuff defined here.

        const VT_NUMBER = debug ? "VT_NUMBER" : 0;
        const VT_TENSOR = debug ? "VT_TENSOR" : 1;
        const VT_ERROR = debug ? "VT_ERROR" : 2;
        const VT_NULL = debug ? "VT_NULL" : 3;

        function makeErr(ctx, info) {
            const err = {
                vt: VT_ERROR,
                val: info
            };
            ctx.errors.push(err);
            return err;
        }

        function vtToString(vt) {
            switch (vt) {
                case VT_NUMBER:
                    return "NUMBER";
                case VT_ERROR:
                    return "ERROR";
                case VT_TENSOR:
                    return "TENSOR";
            }
            return "unknown type " + vt;
        }

        function evaluateNumber(x) {
            return makeNumber(x.text);
        }

        function makeNumber(n) {
            return {
                vt: VT_NUMBER,
                val: parseFloat(n)
            };
        }

        const builtInConstantsMap = {
            PI: makeNumber(Math.PI.toString()),
            E: makeNumber(Math.E.toString()),
            // golden ratio
            PHI: makeNumber("1.618033988749")
        };
        const builtInConstants = Object.keys(builtInConstantsMap);

        function evaluateVariable(ctx, x, err = true) {
            const name = x.text;
            let v = builtInConstantsMap[name];
            if (v) {
                return v;
            }
            v = ctx.variables.get(name);
            if (v) {
                return v;
            }

            if (err) {
                return makeErr(
                    ctx,
                    `the variable ${name} hasn't been declared yet.
    You can do something like ${name} := 2; to declare it. (the semicolon supresses output)`
                );
            }

            return null;
        }

        // the function operator(T1, t2) can be found by doing binOpMatrix[t1][t2][operator].
        const binOpMatrix = {
            [VT_NUMBER]: {
                [VT_NUMBER]: {
                    "+": (a, b) => ({ vt: a.vt, val: a.val + b.val }),
                    "<": (a, b) => ({ vt: a.vt, val: a.val < b.val ? 1.0 : 0.0 }),
                    ">": (a, b) => ({ vt: a.vt, val: a.val > b.val ? 1.0 : 0.0 }),
                    "<=": (a, b) => ({ vt: a.vt, val: a.val <= b.val ? 1.0 : 0.0 }),
                    ">=": (a, b) => ({ vt: a.vt, val: a.val >= b.val ? 1.0 : 0.0 }),
                    "==": (a, b) => ({ vt: a.vt, val: Math.abs(a.val - b.bal) > 0.0000000001 ? 1.0 : 0.0 }),
                    "-": (a, b) => ({ vt: a.vt, val: a.val - b.val }),
                    "*": (a, b) => ({ vt: a.vt, val: a.val * b.val }),
                    "/": (a, b) => ({ vt: a.vt, val: a.val / b.val }),
                    "%": (a, b) => ({ vt: a.vt, val: a.val % b.val }),
                    "^": (a, b) => ({ vt: a.vt, val: Math.pow(a.val, b.val) })
                }
            }
        };

        function applyOperator(ctx, lhs, rhs, op) {
            const t1 = lhs.vt;
            const t2 = rhs.vt;

            let binOp = null,
                binOpL1 = null,
                binOpL2 = null;
            binOpL1 = binOpMatrix[t1];
            if (binOpL1) {
                binOpL2 = binOpL1[t2];
                if (binOpL2) {
                    binOp = binOpL2[op.text];
                }
            }

            if (!binOp) {
                // find the largest common shape, and try to multiply component-wise
                if (t1.vt === VT_TENSOR) {
                }

                return makeErr(
                    ctx,
                    `the operator '${op.text}' doesn't have a mapping from ${vtToString(t1)} -> ${vtToString(
                        t2
                    )}`
                );
            }

            return binOp(lhs, rhs);
        }

        function evaluateChain(ctx, x) {
            let val = evaluateExpression(ctx, x.terms[0]);
            for (let i = 1; i < x.terms.length; i++) {
                const val2 = evaluateExpression(ctx, x.terms[i]);
                val = applyOperator(ctx, val, val2, x.ops[i - 1]);
            }
            return val;
        }

        const unaryOpsMap = {
            [VT_NUMBER]: {
                "+": (x) => x,
                "-": (x) => ({ vt: x.vt, val: -x.val })
            }
        };
        const unaryOps = [];
        for (const typeKey in unaryOpsMap) {
            const opList = unaryOpsMap[typeKey];
            for (const op in opList) {
                unaryOps.push(op);
            }
        }

        function evaluateUnaryOp(ctx, x) {
            const val = evaluateExpression(ctx, x.expr);
            const func = unaryOpsMap[val.vt][x.op.text];
            if (!func) {
                return makeErr(ctx, `unary op ${x.op.text} can't be used on ${vtToString(val.vt)}`);
            }

            return func(val);
        }

        // imagine building an interpreted language in an interpreted language
        // also we need a way to represent infinite args. our tensor function can actually take in infinite number args
        const builtinFunctionsMap = {
            abs: {
                args: [{ vt: VT_NUMBER }],
                fn: (...args) => ({ vt: args[0].vt, val: Math.abs(...args.map((x) => x.val)) })
            },
            acos: {
                args: [{ vt: VT_NUMBER }],
                fn: (...args) => ({ vt: args[0].vt, val: Math.acos(...args.map((x) => x.val)) })
            },
            acosh: {
                args: [{ vt: VT_NUMBER }],
                fn: (...args) => ({ vt: args[0].vt, val: Math.acosh(...args.map((x) => x.val)) })
            },
            asin: {
                args: [{ vt: VT_NUMBER }],
                fn: (...args) => ({ vt: args[0].vt, val: Math.asin(...args.map((x) => x.val)) })
            },
            asinh: {
                args: [{ vt: VT_NUMBER }],
                fn: (...args) => ({ vt: args[0].vt, val: Math.asinh(...args.map((x) => x.val)) })
            },
            atan: {
                args: [{ vt: VT_NUMBER }],
                fn: (...args) => ({ vt: args[0].vt, val: Math.atan(...args.map((x) => x.val)) })
            },
            atanh: {
                args: [{ vt: VT_NUMBER }],
                fn: (...args) => ({ vt: args[0].vt, val: Math.atanh(...args.map((x) => x.val)) })
            },
            atan2: {
                args: [{ vt: VT_NUMBER }, { vt: VT_NUMBER }],
                fn: (...args) => ({ vt: args[0].vt, val: Math.atan2(...args.map((x) => x.val)) })
            },
            ceil: {
                args: [{ vt: VT_NUMBER }],
                fn: (...args) => ({ vt: args[0].vt, val: Math.ceil(...args.map((x) => x.val)) })
            },
            cos: {
                args: [{ vt: VT_NUMBER }],
                fn: (...args) => ({ vt: args[0].vt, val: Math.cos(...args.map((x) => x.val)) })
            },
            cosh: {
                args: [{ vt: VT_NUMBER }],
                fn: (...args) => ({ vt: args[0].vt, val: Math.cosh(...args.map((x) => x.val)) })
            },
            exp: {
                args: [{ vt: VT_NUMBER }],
                fn: (...args) => ({ vt: args[0].vt, val: Math.exp(...args.map((x) => x.val)) })
            },
            floor: {
                args: [{ vt: VT_NUMBER }],
                fn: (...args) => ({ vt: args[0].vt, val: Math.floor(...args.map((x) => x.val)) })
            },
            hypot: {
                args: [{ vt: VT_NUMBER }],
                fn: (...args) => ({ vt: args[0].vt, val: Math.hypot(...args.map((x) => x.val)) })
            },
            imul: {
                args: [{ vt: VT_NUMBER }],
                fn: (...args) => ({ vt: args[0].vt, val: Math.imul(...args.map((x) => x.val)) })
            },
            log: {
                args: [{ vt: VT_NUMBER }],
                fn: (...args) => ({ vt: args[0].vt, val: Math.log(...args.map((x) => x.val)) })
            },
            log1p: {
                args: [{ vt: VT_NUMBER }],
                fn: (...args) => ({ vt: args[0].vt, val: Math.log1p(...args.map((x) => x.val)) })
            },
            log10: {
                args: [{ vt: VT_NUMBER }],
                fn: (...args) => ({ vt: args[0].vt, val: Math.log10(...args.map((x) => x.val)) })
            },
            log2: {
                args: [{ vt: VT_NUMBER }],
                fn: (...args) => ({ vt: args[0].vt, val: Math.log2(...args.map((x) => x.val)) })
            },
            max: {
                args: [{ vt: VT_NUMBER }],
                fn: (...args) => ({ vt: args[0].vt, val: Math.max(...args.map((x) => x.val)) })
            },
            min: {
                args: [{ vt: VT_NUMBER }],
                fn: (...args) => ({ vt: args[0].vt, val: Math.min(...args.map((x) => x.val)) })
            },
            pow: {
                args: [{ vt: VT_NUMBER }, { vt: VT_NUMBER }],
                fn: (...args) => ({ vt: args[0].vt, val: Math.pow(...args.map((x) => x.val)) })
            },
            random: {
                args: [{ vt: VT_NUMBER }],
                fn: (...args) => ({ vt: args[0].vt, val: Math.random(...args.map((x) => x.val)) })
            },
            round: {
                args: [{ vt: VT_NUMBER }],
                fn: (...args) => ({ vt: args[0].vt, val: Math.round(...args.map((x) => x.val)) })
            },
            sign: {
                args: [{ vt: VT_NUMBER }],
                fn: (...args) => ({ vt: args[0].vt, val: Math.sign(...args.map((x) => x.val)) })
            },
            sin: {
                args: [{ vt: VT_NUMBER }],
                fn: (...args) => ({ vt: args[0].vt, val: Math.sin(...args.map((x) => x.val)) })
            },
            sinh: {
                args: [{ vt: VT_NUMBER }],
                fn: (...args) => ({ vt: args[0].vt, val: Math.sinh(...args.map((x) => x.val)) })
            },
            sqrt: {
                args: [{ vt: VT_NUMBER }],
                fn: (...args) => ({ vt: args[0].vt, val: Math.sqrt(...args.map((x) => x.val)) })
            },
            tan: {
                args: [{ vt: VT_NUMBER }],
                fn: (...args) => ({ vt: args[0].vt, val: Math.tan(...args.map((x) => x.val)) })
            },
            tanh: {
                args: [{ vt: VT_NUMBER }],
                fn: (...args) => ({ vt: args[0].vt, val: Math.tanh(...args.map((x) => x.val)) })
            },
            trunc: {
                args: [{ vt: VT_NUMBER }],
                fn: (...args) => ({ vt: args[0].vt, val: Math.trunc(...args.map((x) => x.val)) })
            },
            T: {
                args: [{ vt: VT_NUMBER}],
                fn: (...args) => ({ vt: VT_TENSOR, data: Array(args.map(x => x.val).reduce((prev, next) => prev * next, 1)).fill(0), shape: args.map(x => x.val) })  // no error checks? TODO: add. later, of
            }
        };
        const builtinFunctions = Object.keys(builtinFunctionsMap);

        function evaluateFunctionCall(ctx, x) {
            const name = x.name.text;
            const func = builtinFunctionsMap[name];
            if (!func) {
                return makeErr(ctx, `function '${name}' not found`);
            }

            const argsEvaluated = x.args.map((arg) => evaluateExpression(ctx, arg));

            // I don't care if the argument counts don't match at the moment.
            // some of the javascript math functions might accept variadic ...args,
            // and it is more important that I am able to use that than it is that I get errors about argument counts
            // at the moment.

            for (let i = 0; i < func.args.length; i++) {
                if (argsEvaluated[i].vt !== func.args[i].vt) {
                    return makeErr(
                        ctx,
                        `Argument ${i} to function ${name} was of type ${vtToString(
                            argsEvaluated[i].vt
                        )}, but it wants ${vtToString(func.args[i].vt)}`
                    );
                }
            }

            return func.fn(...argsEvaluated);
        }

        function evaluateAssignment(ctx, x) {
            if (x.lhs.t !== T_IDENT && x.lhs.t !== T_TENSOR) {
                return makeErr(ctx, `'${ctx.text.substring(x.start, x.end)}' - invalid assignment`);
            }

            let ident = x.lhs.text;
            if (!ident) {
                return makeErr(ctx, `identifier was blank`);
            }

            if (builtinFunctions.includes(ident)) {
                // compilers need more of this I think. what could possibly go wrong?
                return makeErr(ctx, Math.random() < 0.05 ? `NOO!!! you cant just redeclare functions !!!` : `a builtin function already exists with this name`) 
            }

            const rhs = evaluateExpression(ctx, x.rhs);
            const existingVar = evaluateVariable(ctx, x.lhs, false);

            if (x.isDeclaration) {
                if (existingVar !== null) {
                    return makeErr(ctx, Math.random() < 0.05 ? `NOOOO!! you cant just redefine ${ident} to be ${rhs.val}` : `variable ${ident} already defined, with value: ${existingVar.val}`);
                }
            } else {
                if (existingVar === null) {
                    return makeErr(
                        ctx,
                        `variable ${ident} does not yet exist, do ${ident} := ${x.rhs.text} if you wanted to create a new variable`
                    );
                }
            }

            ctx.variables.set(ident, rhs);
            return rhs;
        }

        function evaluateTernary(ctx, x) {
            const condition = evaluateExpression(ctx, x.conditional);
            if (condition.vt !== VT_NUMBER) {
                return makeErr(
                    ctx,
                    `condition needs to be a number, anything less than 0.5 is false, anything >= 0.5 is true`
                );
            }

            if (condition.val >= 0.5) {
                return evaluateExpression(ctx, x.ifTrue);
            }

            return evaluateExpression(ctx, x.else);
        }

        // takes in two shapes, not two tensors
        function areSameShape(s1, s2) {
            if (s1.length !== s2.length) return false;

            for (const i in s1) {
                if (s1[i] !== s2[i]) return false;
            }

            return true;
        }

        function evaluateTensor(ctx, x) {
            const depthFirstEvalTensor = (x) => {
                if (x.t !== T_TENSOR) {
                    let val = evaluateExpression(ctx, x);
                    if (val.vt === VT_NUMBER || val.vt === VT_TENSOR) {
                        return val;
                    }

                    return makeErr(
                        ctx,
                        `bottom level item ${ctx.text.substring(
                            x.start,
                            x.end
                        )} in tensor not of correct type - ${vtToString(val.vt)}`
                    );
                }

                const tensor = {
                    vt: VT_TENSOR,
                    data: [],
                    shape: []
                };

                let expectedShape = null;
                for (let i = 0; i < x.rows.length; i++) {
                    let row = depthFirstEvalTensor(x.rows[i]);
                    if (row.vt === VT_ERROR) {
                        return row;
                    }

                    if (row.vt === VT_TENSOR) {
                        if (expectedShape === null) {
                            expectedShape = row.shape;
                        } else if (!areSameShape(expectedShape, row.shape)) {
                            return makeErr(
                                ctx,
                                `one of the elements of the tensor was the wrong size: ${ctx.text.substring(
                                    x.rows[i].start,
                                    x.rows[i].end
                                )}`
                            );
                        }

                        tensor.data.push(...row.data);
                    } else if (row.vt === VT_NUMBER) {
                        expectedShape = [];
                        tensor.data.push(row.val);
                    }
                }

                tensor.shape = [x.rows.length, ...expectedShape];

                return tensor;
            };

            const tensor = depthFirstEvalTensor(x);

            return tensor;
        }

        function evaluateExprIndexation(ctx, x) {
            const expr = evaluateExpression(ctx, x.expr)
            // eventually, indexes themselves can be tensors
            const indexes = x.indexes.map(x => evaluateExpression(ctx, x))

            if (expr.vt !== VT_TENSOR) {
                return makeErr(ctx, `the type ${vtToString(expr.vt)} cannot be indexed`);
            }

            let cumulativeSizes = Array(expr.shape.length);
            cumulativeSizes[cumulativeSizes.length - 1] = expr.shape[cumulativeSizes.length - 1];
            for(let i = expr.shape.length - 2; i >= 0; i--) {
                cumulativeSizes[i] = expr.shape[i] * expr.shape[i+1];
            }

            let start = 0;
            for(let i = 0; i < x.indexes.length; i++) {
                start += (cumulativeSizes[i + 1] || 1) * indexes[i].val;
            }

            if (indexes.length === cumulativeSizes.length) {
                return makeNumber(expr.data[start]);
            }

            return {
                vt: VT_TENSOR,
                shape: expr.shape.slice(indexes.length),
                data: expr.data.slice(start, start + cumulativeSizes[indexes.length])
            };
        }

        function evaluateExpression(ctx, x) {
            if (!x) {
                throw new Error("expression not defined");
            }

            const type = x.t;
            let value;

            switch (type) {
                case T_NUMBER:
                    value = evaluateNumber(x);
                    break;
                case T_BUILTIN_CONSTANT:
                case T_IDENT:
                    value = evaluateVariable(ctx, x);
                    break;
                case T_EXPR_INDEXATION:
                    value = evaluateExprIndexation(ctx, x);
                    break;
                case T_EXPR:
                case T_TERM:
                    value = evaluateChain(ctx, x);
                    break;
                case T_UNARY_OP:
                    value = evaluateUnaryOp(ctx, x);
                    break;
                case T_FUNCTION_CALL:
                    value = evaluateFunctionCall(ctx, x);
                    break;
                case T_ASSIGNMENT:
                    value = evaluateAssignment(ctx, x);
                    break;
                case T_TERNARY:
                    value = evaluateTernary(ctx, x);
                    break;
                case T_TENSOR:
                    value = evaluateTensor(ctx, x);
                    break;
                default:
                    value = makeErr(ctx, "Unknown ast node type");
                    break;
            }

            return value;
        }

        function evaluateProgram(program, text) {
            const ctx = {
                variables: new Map(),
                errors: [],
                text: text
            };

            if (program.error) {
                makeErr(ctx, program.error);
            }

            ctx.results = program.expressions.map((line) => {
                let val = {
                    ...evaluateExpression(ctx, line)
                };

                val.show = line.show;
                val.lineNumber = line.lineNumber;
                return val;
            });

            return ctx;
        }

        // not a particularly good visualisation. TODO: improve
        function tensorToString(t) {
            if (t.vt !== VT_TENSOR) {
                return valueToString(t);
            }

            let counter = 0;
            const dfs = (level) => {
                if (level === t.shape.length) {
                    let val = t.data[counter];
                    counter ++;
                    return val;
                }
                
                let stringBuilder = [];
                for (let i = 0; i < t.shape[level]; i++) {
                    stringBuilder.push(dfs(level + 1));
                }

                const joinStr = level === t.shape.length - 1 ? ", " : ", \n";
                return "[" + stringBuilder.join(joinStr) + "]";
            }

            let dataStr = dfs(0);
            
            return "shape: " + t.shape.join("x") + ", data: \n" + dataStr.replace(/\n/g, "\n\t");
        }

        function valueToString(v) {
            switch (v.vt) {
                case VT_TENSOR:
                    return "\n\t" + tensorToString(v).replace("\n", "\n\t");
                default:
                    return `${v.val}`;
            }
        }

        function thingToString(v) {
            let type = vtToString(v.vt);
            let str = valueToString(v);

            return `[${type}]: ${str}`;
        }

        // ---- parser

        const T_EXPR = debug ? "T_EXPR" : 0;
        const T_NUMBER = debug ? "T_NUMBER" : 1;
        const T_OP_EXPR = debug ? "T_OP_EXPR" : 2;
        const T_OP_TERM = debug ? "T_OP_TERM" : 3;
        const T_TERM = debug ? "T_TERM" : 4;
        const T_BUILTIN_CONSTANT = debug ? "T_BUILTIN_CONSTANT" : 5;
        const T_UNARY_OP = debug ? "T_UNARY_OP" : 6;
        const T_IDENT = debug ? "T_IDENT" : 7; // arbitrary text, could be anything.
        const T_FUNCTION_CALL = debug ? "T_FUNCTION_CALL" : 8;
        const T_OP_EXPONENT = debug ? "T_OP_EXPONENT" : 9;
        const T_ASSIGNMENT = debug ? "T_ASSIGNMENT" : 10;
        const T_TERNARY = debug ? "T_TERNARY" : 11;
        const T_TENSOR = debug ? "T_TENSOR" : 12;
        const T_EXPR_INDEXATION = debug ? "T_EXPR_INDEXATION" : 13;

        // Thankyou Trevor https://stackoverflow.com/questions/1496826/check-if-a-single-character-is-a-whitespace
        function isWhitespace(c) {
            return (
                c === " " ||
                c === "\n" ||
                c === "\t" ||
                c === "\r" ||
                c === "\f" ||
                c === "\v" ||
                c === "\u00a0" ||
                c === "\u1680" ||
                c === "\u2000" ||
                c === "\u200a" ||
                c === "\u2028" ||
                c === "\u2029" ||
                c === "\u202f" ||
                c === "\u205f" ||
                c === "\u3000" ||
                c === "\ufeff"
            );
        }

        function isDigit(c) {
            return (
                c === "1" ||
                c === "2" ||
                c === "3" ||
                c === "4" ||
                c === "5" ||
                c === "6" ||
                c === "7" ||
                c === "8" ||
                c === "9" ||
                c === "0"
            );
        }

        function isLetter(c) {
            return c.toUpperCase() != c.toLowerCase() || c.codePointAt(0) > 127;
        }

        // this code also parses comments.
        // This way, comments can appear almost anywhere in the
        function advanceWhileWhitespace(text, pos) {
            if (debug) {
                if (typeof text !== "string") {
                    throw new Error("you might be calling advanceWhileWhitespace wrong");
                }
            }

            while (
                pos < text.length &&
                (isWhitespace(text[pos]) || (text[pos] === "/" && text[pos + 1] === "/"))
            ) {
                // single line comment, ignore all text on the same line after //.
                // TODO: figure out how we can actually store these comments and use them
                // in a meaningful way
                if (text[pos] === "/") {
                    pos += 2;
                    while (pos < text.length && text[pos] !== "\n") {
                        pos++;
                    }
                }

                pos++;
            }
            return pos;
        }

        function hasText(text, pos, comp) {
            if (pos + comp.length > text.length) {
                return false;
            }

            return text.substring(pos, pos + comp.length) === comp;
        }

        // parses one of some array possible delimiters. oneOfWhat is an array of possible strings
        function parseOneOf(text, ctx, lines, possibleDelimiters, type) {
            const pos = advanceWhileWhitespace(text, ctx.pos);
            ctx.pos = pos;

            for (let i in possibleDelimiters) {
                const end = pos + possibleDelimiters[i].length;
                if (!hasText(text, pos, possibleDelimiters[i])) {
                    continue;
                }

                ctx.pos = end;
                lines.push({
                    t: type,
                    start: pos,
                    end: end,
                    text: text.substring(pos, end)
                });
                return true;
            }

            return false;
        }

        // operators with the same precedence as addition
        function parseOpExpr(text, ctx, ops) {
            return parseOneOf(text, ctx, ops, ["+", "-", ">", "<", ">=", "<=", "=="], T_OP_EXPR);
        }

        // one of *, /, %
        function parseOpTerm(text, ctx, ops) {
            return parseOneOf(text, ctx, ops, ["*", "/", "%", "^"], T_OP_TERM);
        }

        // one of ^
        function parseOpExponent(text, ctx, ops) {
            return parseOneOf(text, ctx, ops, ["^"], T_OP_EXPONENT);
        }

        // operators with the same precedence as multiplication
        function parseNumber(text, ctx, terms) {
            const start = advanceWhileWhitespace(text, ctx.pos);
            if (start >= text.length) {
                return false;
            }

            let pos = start;
            let foundDecimal = false;
            while (pos < text.length && (isDigit(text[pos]) || (!foundDecimal && text[pos] === "."))) {
                if (text[pos] === ".") {
                    foundDecimal = true;
                }

                pos++;
            }

            if (start === pos) {
                return false;
            }

            terms.push({
                t: T_NUMBER,
                start: start,
                end: pos,
                text: text.substring(start, pos)
            });
            ctx.pos = pos;
            return true;
        }

        // Parses a series of terms like <term> (<operator> <term>)*
        // the parsers for term and operator can be specified as functions
        function parseChain(text, ctx, lines, type, termParser, opParser) {
            let start = advanceWhileWhitespace(text, ctx.pos);
            if (start >= text.length) {
                return false;
            }

            const terms = [];
            const ops = [];

            if (!termParser(text, ctx, terms)) {
                return false;
            }

            while (opParser(text, ctx, ops)) {
                if (!termParser(text, ctx, terms)) {
                    // remove the last operator we parsed, we shouldn't have
                    const op = ops.pop();

                    // reset end
                    ctx.pos = terms[terms.length - 1].end;
                    break;
                }
            }

            if (terms.length === 1) {
                // unwraps a single term to be it's own thing.
                // the AST becomes unmanageably large if we don't unwrap nodes like this.
                // although performance might be better, it is mainly a debugging optimization
                lines.push(terms[0]);
            } else {
                lines.push({
                    t: type,
                    start: start,
                    end: ctx.pos,
                    text: text.substring(start, ctx.pos),
                    terms: terms,
                    ops: ops,
                    show: false,
                    lineNumber: 0
                });
            }

            return true;
        }

        function parseGroup(text, ctx, lines) {
            const start = advanceWhileWhitespace(text, ctx.pos);
            if (start >= text.length) {
                return false;
            }

            if (text[start] === "(") {
                ctx.pos = start + 1;
                if (parseTopLevelItem(text, ctx, lines)) {
                    ctx.pos = advanceWhileWhitespace(text, ctx.pos);
                    if (text[ctx.pos] === ")") {
                        lines[lines.length - 1].start = start;
                        lines[lines.length - 1].end++;
                        ctx.pos++;
                        return true;
                    }
                }
            }
            return false;
        }

        // also parses a tensor indexing op like x[1][1][1]
        function parseVariable(text, ctx, lines) {
            const start = ctx.pos;

            if (!parseIdentifier(text, ctx, lines)) return false;
            return true;
        }

        function parseUnaryOp(text, ctx, lines) {
            const start = advanceWhileWhitespace(text, ctx.pos);
            if (start >= text.length) {
                return false;
            }

            const op = [];
            const expr = [];

            ctx.pos = start;
            if (!parseOneOf(text, ctx, op, unaryOps, T_UNARY_OP)) {
                return false;
            }

            ctx.pos = advanceWhileWhitespace(text, ctx.pos);
            if (!parseTopLevelItem(text, ctx, expr)) {
                return false;
            }

            lines.push({
                t: T_UNARY_OP,
                start: start,
                end: ctx.pos,
                op: op[0],
                expr: expr[0]
            });
            return true;
        }

        function parseIdentifier(text, ctx, lines) {
            const start = advanceWhileWhitespace(text, ctx.pos);
            if (start >= text.length) {
                return false;
            }

            let pos = start;
            if (!isLetter(text[pos])) {
                return false;
            }
            pos++;

            while (pos < text.length && (isDigit(text[pos]) || isLetter(text[pos]))) {
                pos++;
            }

            ctx.pos = pos;

            lines.push({
                t: T_IDENT,
                start: start,
                end: ctx.pos,
                text: text.substring(start, ctx.pos)
            });

            return true;
        }

        // wrongly assumes there will always be at least one element in this list
        // also, hasTerminator only works when the terminator is length=1. we need to write it properly next time, or later
        function parseDelimitedList(text, ctx, lines, exprParser, hasDelimiter, hasTerminator) {
            const start = advanceWhileWhitespace(text, ctx.pos);
            if (start >= text.length) {
                return false;
            }

            ctx.pos = start;
            let terminated = false;
            while (exprParser(text, ctx, lines)) {
                const nextStartPos = advanceWhileWhitespace(text, ctx.pos);
                if (hasDelimiter(text, nextStartPos)) {
                    //text[nextStartPos] === delimiter
                    ctx.pos = nextStartPos + 1;
                    continue;
                }

                if (hasTerminator(text, nextStartPos)) {
                    // text[nextStartPos] === terminator
                    ctx.pos = nextStartPos + 1;
                    terminated = true;
                    break;
                }

                return false;
            }

            if (!terminated) {
                // allow for things like [1,2,] (trailing comma)
                ctx.pos = advanceWhileWhitespace(text, ctx.pos);
                if (hasTerminator(text, ctx.pos)) {
                    ctx.pos += 1;
                }
            }

            return true;
        }

        function parseFunctionCall(text, ctx, lines) {
            const start = advanceWhileWhitespace(text, ctx.pos);
            if (start >= text.length) {
                return false;
            }

            const name = [];
            const args = [];

            ctx.pos = start;
            if (!parseIdentifier(text, ctx, name)) {
                return false;
            }

            if (text[ctx.pos] != "(") {
                return false;
            }
            ctx.pos++;

            const argsStartPos = advanceWhileWhitespace(text, ctx.pos);

            ctx.pos = argsStartPos;
            if (text[argsStartPos] === ")") {
                ctx.pos += 1;
            } else {
                if (
                    !parseDelimitedList(
                        text,
                        ctx,
                        args,
                        parseTopLevelItem,
                        (t, pos) => hasText(t, pos, ","),
                        (t, pos) => hasText(t, pos, ")")
                    )
                ) {
                    return false;
                }
            }

            lines.push({
                t: T_FUNCTION_CALL,
                start: start,
                end: ctx.pos,
                name: name[0],
                args: args
            });

            return true;
        }

        // it assumes the starting pos already has a digit. don't call it otherwise
        function parseIntInline(text, ctx) {
            const start = ctx.pos;
            while (ctx.pos < text.length && isDigit(text[ctx.pos])) {
                ctx.pos++;
            }

            return parseInt(text.substring(start, ctx.pos));
        }

        // surprisingly complicated
        function parseTensor(text, ctx, lines) {
            const start = advanceWhileWhitespace(text, ctx.pos);
            if (start >= text.length) {
                return false;
            }

            const shape = [];

            if (text[start] !== "[") {
                return false;
            }

            ctx.pos = advanceWhileWhitespace(text, start + 1);

            const rows = [];
            // probably more optimal to only be parsing tensors or numbers here.
            if (
                !parseDelimitedList(
                    text,
                    ctx,
                    rows,
                    parseTopLevelItem,
                    (t, pos) => hasText(t, pos, ","),
                    (t, pos) => hasText(t, pos, "]")
                )
            ) {
                return false;
            }

            // we need to figure out the shape, and evaluate the inline expressions later in the evaluation step
            lines.push({
                t: T_TENSOR,
                start: start,
                end: ctx.pos,
                rows: rows,
                evaluated: false
            });
            return true;
        }

        function parseThing(text, ctx, lines) {
            const start = advanceWhileWhitespace(text, ctx.pos);
            if (start >= text.length) {
                return false;
            }

            ctx.pos = start;
            if (parseGroup(text, ctx, lines)) return true;

            ctx.pos = start;
            if (parseUnaryOp(text, ctx, lines)) return true;

            ctx.pos = start;
            if (parseFunctionCall(text, ctx, lines)) return true;

            // important that this is after parseFunctionCall and what have you, the function name will be confused for a variable otherwise
            ctx.pos = start;
            if (parseVariable(text, ctx, lines)) return true;

            // primitives

            ctx.pos = start;
            if (parseNumber(text, ctx, lines)) return true;

            ctx.pos = start;
            if (parseTensor(text, ctx, lines)) return true;

            return false;
        }

        function parseExponent(text, ctx, lines) {
            return parseChain(text, ctx, lines, T_TERM, parseThing, parseOpExponent);
        }

        function parseTerm(text, ctx, lines) {
            return parseChain(text, ctx, lines, T_TERM, parseExponent, parseOpTerm);
        }

        function parseExpression(text, ctx, lines) {
            return parseChain(text, ctx, lines, T_EXPR, parseTerm, parseOpExpr);
        }

        function parseIndexation(text, ctx, indexes) {
            if(text[ctx.pos] !== "[") {
                return false;
            }

            while (hasText(text, ctx.pos, "[")) {
                ctx.pos = advanceWhileWhitespace(text, ctx.pos + 1);

                if (!parseTopLevelItem(text, ctx, indexes)) return false;

                ctx.pos = advanceWhileWhitespace(text, ctx.pos);
                if (!text[ctx.pos] === "]") {
                    return false;
                }
                ctx.pos = advanceWhileWhitespace(text, ctx.pos + 1);
            }

            return true;
        }

        function parseTopLevelItem(text, ctx, lines) {
            const start = ctx.pos;
            if (!parseTernary(text, ctx, lines)) return false;

            const indexes = [];
            ctx.pos = advanceWhileWhitespace(text, ctx.pos);
            if (!parseIndexation(text, ctx, indexes)) return true;

            lines[lines.length - 1] = {
                t: T_EXPR_INDEXATION,
                start: start,
                end: ctx.pos,
                expr: lines[lines.length - 1],
                indexes: indexes
            };
            return true;
        }

        function parseTernary(text, ctx, lines) {
            const expr = [];
            if (!parseExpression(text, ctx, expr)) return false;

            const ternaryStart = advanceWhileWhitespace(text, ctx.pos);
            ctx.pos = ternaryStart;
            if (text[ctx.pos] !== "?") {
                // we only got an expression, that is fine
                lines.push(expr[0]);
                return true;
            }

            ctx.pos = advanceWhileWhitespace(text, ctx.pos + 1);

            if (!parseExpression(text, ctx, expr)) return false;

            ctx.pos = advanceWhileWhitespace(text, ctx.pos);
            if (text[ctx.pos] !== ":") {
                // we only got one branch of the ternary, that isn't enough
                return false;
            }

            // the next part can also be a ternary, i.e
            // x := y < 0 ? 2 : y > 3 ? 3 : 0

            ctx.pos = advanceWhileWhitespace(text, ctx.pos + 1);
            if (!parseTernary(text, ctx, expr)) {
                // we weren't able to parse the second branch of the ternary
                return false;
            }

            lines.push({
                t: T_TERNARY,
                start: ternaryStart,
                end: ctx.pos,
                conditional: expr[0],
                ifTrue: expr[1],
                else: expr[2]
            });
            return true;
        }

        function parseAssignment(text, ctx, lines) {
            const start = advanceWhileWhitespace(text, ctx.pos);
            if (start >= text.length) {
                return false;
            }

            const expr = [];
            if (!parseTopLevelItem(text, ctx, expr)) return false;

            const assignOpPos = advanceWhileWhitespace(text, ctx.pos);

            let isDeclaration = false;
            if (hasText(text, assignOpPos, "=")) {
                ctx.pos = assignOpPos + 1;
            } else if (hasText(text, assignOpPos, ":=")) {
                ctx.pos = assignOpPos + 2;
                isDeclaration = true;
            } else {
                lines.push(expr[0]);
                return true;
            }

            if (!parseTopLevelItem(text, ctx, expr)) return false;

            lines.push({
                t: T_ASSIGNMENT,
                start: start,
                end: ctx.pos,
                lhs: expr[0],
                rhs: expr[1],
                isDeclaration: isDeclaration
            });
            return true;
        }

        function parseExpressionList(text, ctx, list) {
            const start = ctx.pos;

            while (parseAssignment(text, ctx, list)) {
                const endsWithSemicolon = text[ctx.pos] === ";";

                const lastAdded = list[list.length - 1];
                lastAdded.show = !endsWithSemicolon;
                lastAdded.lineNumber = text.substring(0, lastAdded.start).split("\n").length - 1;

                if (endsWithSemicolon) {
                    ctx.pos++;
                }
            }

            return start !== ctx.pos;
        }

        // return an AST-like thing
        function parseProgram(text) {
            const ctx = { pos: 0 };
            const lines = [];

            while (parseExpressionList(text, ctx, lines)) {}
            ctx.pos = advanceWhileWhitespace(text, ctx.pos);

            const root = {
                expressions: lines,
                error: null
            };

            if (ctx.pos !== text.length) {
                const lines = text.substring(0, ctx.pos).split("\n");
                const linePos = ctx.pos - lines.lastIndexOf("\n");
                let contextText = text.substring(ctx.pos);
                if (contextText.length > 50) {
                    contextText = contextText.substring(0, 50) + "...";
                }
                root.error = `Couldn't read line ${lines.length} pos ${linePos}: "${contextText}"`;
            }

            return root;
        }

        function debugFormatAST(ast, text) {
            const dfs = (node) => {
                if (typeof node === "string") {
                    return;
                }

                if (node === null || node === undefined) {
                    return "undefined";
                }

                if (typeof node.start === "number" && typeof node.end === "number") {
                    // node.val = evaluateProgram(node.text);
                    delete node.start;
                    delete node.end;
                }

                const limit = 10;
                if (
                    typeof node.length === "number" &&
                    node.length > limit &&
                    node.push !== undefined &&
                    node.splice !== undefined
                ) {
                    let originalLength = node.length;
                    node.splice(limit, node.length - limit);
                    node.push(
                        "and " +
                            (originalLength - limit) +
                            " more items that have been hidden for performance reasons"
                    );
                }

                for (const k of Object.keys(node)) {
                    dfs(node[k]);
                }
            };

            dfs(ast);
            return ast;
        }

        // ---- actual website code

        const input = document.getElementById("input");
        const showAstCheckbox = document.getElementById("show-ast-checkbox");
        const showResultCheckbox = document.getElementById("show-result-checkbox");
        const showAstOutput = document.getElementById("ast-output");
        const showResultOutput = document.getElementById("result-output");

        // HTML doesn't like tabs, we need this additional code to be able to insert tabs.
        input.addEventListener("keydown", (e) => {
            if (e.keyCode !== 9) return;

            e.preventDefault();

            var start = input.selectionStart;
            var end = input.selectionEnd;

            // set textarea value to: text before caret + tab + text after caret
            input.value = input.value.substring(0, start) + "\t" + input.value.substring(end);

            // put caret at right position again
            input.selectionStart = input.selectionEnd = start + 1;

            onInputChange();
        });

        const onInputChange = () => {
            rerender();
        };

        input.addEventListener("input", onInputChange);

        showAstCheckbox.addEventListener("change", () => {
            rerender();
        });

        showResultCheckbox.addEventListener("change", () => {
            rerender();
        });

        function rerender() {
            // line numbers.
            document.getElementById("line-numbers").innerText = [
                ...Array(input.value.split("\n").length).keys()
            ].join("\n");

            // debug outputs

            if (showAstCheckbox.checked) {
                showAstOutput.removeAttribute("hidden");
            } else {
                showAstOutput.setAttribute("hidden", true);
            }

            if (showResultCheckbox.checked) {
                showResultOutput.removeAttribute("hidden");
            } else {
                showResultOutput.setAttribute("hidden", true);
            }

            // compile and interpret code

            const text = input.value;
            const ast = parseProgram(text);
            const result = evaluateProgram(ast, text);

            const getClass = (v) => {
                if (v.vt == VT_ERROR) {
                    return "error";
                }

                return "";
            };

            let resultsTextOutput = [];

            // // code to align results with the line the expression appeared on.
            // if (result.results.length > 0) {
            //     let currentResultIndex = 0;
            //     for(let ln = 0; ln <= result.results[result.results.length - 1].lineNumber; ln++) {
            //         const v = result.results[currentResultIndex];
            //         if (v.lineNumber === ln) {
            //             resultsTextOutput.push(v.show ? `[${vtToString(v.vt)}]: ${v.val}` : "");
            //             currentResultIndex++;
            //             console.log(currentResultIndex)
            //         } else {
            //             console.log(currentResultIndex)
            //             resultsTextOutput.push("");
            //         }
            //     }
            // }
            resultsTextOutput = result.results
                .map((v) => (v.show ? thingToString(v) : undefined))
                .filter((v) => !!v);
            resultsTextOutput = resultsTextOutput.join("\n");

            const errorsTextOutput =
                result.errors.length === 0
                    ? ""
                    : "<pre>All errors:</pre>" +
                      result.errors
                          .map((v) => {
                              return `<pre class="error">${thingToString(v)}</pre>`;
                          })
                          .join("");

            // print result(s)
            document.getElementById("output").innerHTML =
                errorsTextOutput.length > 0 ? errorsTextOutput : resultsTextOutput;

            // debug output

            showAstOutput.innerText = JSON.stringify(debugFormatAST(ast, text), null, 4);
            showResultOutput.innerText = JSON.stringify(result, null, 4);
        }


        // ---- set value

        input.value = "[1,2,3][1]";
        rerender();

        // ---- add testcases,

        const testcases = [
            {
                name: "order of operations",
                input: `1 * 2 + 3 * 2^2`,
                expected: "14"
            },
            {
                name: "brackets",
                input: `2^(1+1) + (2 * 3)`,
                expected: "10"
            },
            {
                name: "variables",
                input: `x := 3;
y := 33 * x;
x = y * x + x`,
                expected: "300"
            },
            {
                name: "assignment errors",
                input: `3 := 3;
x = 3;
y := 3;
y := 3;
`,
                expected: "errors"
            },
            {
                name: "builtin math functions",
                input: "sin(PI) + cos(PI)",
                expected: "-1 (cries in floating point)"
            },
            {
                name: "errors",
                input: "sin(x)",
                expected: "errors"
            },
            {
                name: "line comments",
                input: "x := // 324234 * sin(x)\n3; x",
                expected: "3"
            },
            {
                name: "ternary",
                input: "0 ? 100 : 2^2",
                expected: "4"
            },
            {
                name: "inline tensor",
                input: "[[1, 2, 3], [1, 2, 3]]",
                expected: "a tensor"
            },
            {
                name: "tensor func",
                input: "T(10, 10)",
                expected: "a tensor"
            }
        ];

        const testcaseContainer = document.getElementById("testcases");
        testcaseContainer.innerHTML =
            `
            <tr><th>Name</th><th>Input</th><th>Expected</th></tr>
        ` +
            testcases
                .map((testcase, i) => {
                    return `<tr><td><button class="testcase-button" data-testcase-id="${i}">${testcase.name}</button></td><td>${testcase.input}</td><td>${testcase.expected}</td></tr>`; // isn't this code great or what
                })
                .join("\n");

        testcaseContainer.querySelectorAll(".testcase-button").forEach((button) => {
            button.addEventListener("click", (e) => {
                input.value = testcases[parseInt(button.getAttribute("data-testcase-id"))].input;
                rerender();
            });
        });

        // ---- zen mode

        const zenMode = document.getElementById("zen-mode");
        zenMode.addEventListener("click", () => {
            document.querySelectorAll(".not-zen").forEach((el) => {
                el.setAttribute("hidden", true);
            });
        });

        document.addEventListener("keydown", (e) => {
            if (e.key === "Escape") {
                document.querySelectorAll(".not-zen").forEach((el) => {
                    el.removeAttribute("hidden", true);
                });
            }
        });

        // ---- end
    </script>
</html>
