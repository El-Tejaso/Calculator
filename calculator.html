<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>calculator</title>
    </head>
    <style>
        body :focus {
            outline: none;
        }

        #input {
            padding-left: 5px;
            background: #555555;
            color: #ffffff;
        }

        .code div:before {
            content: "|";
            width: 20px;
        }
    </style>
    <body style="font-family: 'Source Code Pro', monospace; margin: 0px">
        <div style="display: absolute; width: 100%; height: 100%">
            <div id="input" contenteditable="plaintext-only"></div>
            <pre id="output" style="padding: 5px">yo</pre>
        </div>
    </body>
    <script>
        const debug = true;

        const T_EXPR = debug ? "T_EXPR" : 0;
        const T_NUMBER = debug ? "T_NUMBER" : 1;
        const T_OP_EXPR = debug ? "T_OP_EXPR" : 2;
        const T_OP_TERM = debug ? "T_OP_TERM" : 3;
        const T_TERM = debug ? "T_TERM" : 4;

        // ---- parser

        // Thankyou Trevor bro https://stackoverflow.com/questions/1496826/check-if-a-single-character-is-a-whitespace
        function isWhitespace(c) {
            return (
                c === " " ||
                c === "\n" ||
                c === "\t" ||
                c === "\r" ||
                c === "\f" ||
                c === "\v" ||
                c === "\u00a0" ||
                c === "\u1680" ||
                c === "\u2000" ||
                c === "\u200a" ||
                c === "\u2028" ||
                c === "\u2029" ||
                c === "\u202f" ||
                c === "\u205f" ||
                c === "\u3000" ||
                c === "\ufeff"
            );
        }

        function isDigit(c) {
            return (
                c === "1" ||
                c === "2" ||
                c === "3" ||
                c === "4" ||
                c === "5" ||
                c === "6" ||
                c === "7" ||
                c === "8" ||
                c === "9" ||
                c === "0"
            );
        }

        function advanceWhileWhitespace(text, pos) {
            while (pos < text.length && isWhitespace(text[pos])) pos++;
            return pos;
        }

        function parseOneOf(text, ctx, lines, oneOfWhat, type) {
            const pos = advanceWhileWhitespace(text, ctx.pos);
            for (let i in oneOfWhat) {
                if (pos + oneOfWhat[i].length >= text.length) {
                    continue;
                }

                if (text.substring(pos, pos + oneOfWhat[i].length) === oneOfWhat[i]) {
                    const end = pos + oneOfWhat[i].length;
                    lines.push({
                        t: type,
                        start: pos,
                        end: end,
                        value: text.substring(pos, end)
                    });

                    ctx.pos = end;

                    return true;
                }
            }

            return false;
        }

        // one of +, -
        function parseOpExpr(text, ctx, ops) {
            return parseOneOf(text, ctx, ops, ["+", "-"], T_OP_EXPR);
        }

        // one of *, /, %
        function parseOpTerm(text, ctx, ops) {
            return parseOneOf(text, ctx, ops, ["*", "/", "%"], T_OP_TERM);
        }

        // /\d*(\.\d*)?/
        function parseNumber(text, ctx, terms) {
            const start = advanceWhileWhitespace(text, ctx.pos);
            let pos = start;
            let foundDecimal = false;
            while (pos < text.length && (isDigit(text[pos]) || (!foundDecimal && text[pos] === "."))) {
                if (text[pos] === ".") {
                    foundDecimal = true;
                }

                pos++;
            }

            if (start === pos) {
                return false;
            }

            terms.push({
                t: T_NUMBER,
                start: start,
                end: pos,
                value: text.substring(start, pos)
            });
            ctx.pos = pos;
            return true;
        }

        // <term> (<opExpr> <term>)*
        function parseChain(text, ctx, lines, type, termParser, opParser) {
            const terms = [];
            const ops = [];

            let start = ctx.pos;

            if (!termParser(text, ctx, terms)) {
                return false;
            }

            while (opParser(text, ctx, ops)) {
                if (!termParser(text, ctx, terms)) {
                    // remove the last operator we parsed, we shouldn't have
                    const op = ops.pop();

                    // reset end
                    ctx.pos = terms[terms.length - 1].end;
                    break;
                }
            }

            if (terms.length === 1) {
                lines.push(terms[0]);
            } else {
                lines.push({
                    t: type,
                    start: start,
                    end: ctx.pos,
                    terms: terms,
                    ops: ops
                });
            }

            return true;
        }

        // code aesthetics hack. hahaha
        function setPos(ctx, pos) {
            ctx.pos = pos;
            return true;
        }

        function parseThing(text, ctx, lines) {
            const start = advanceWhileWhitespace(text, ctx.pos);

            if (text[start] === "(" && setPos(ctx, start + 1) && parseExpression(text, ctx, lines)) {
                ctx.pos = advanceWhileWhitespace(text, ctx.pos);
                if (text[ctx.pos] === ")") {
                    lines[lines.length - 1].start = start;
                    lines[lines.length - 1].end++;
                    ctx.pos++;
                    return true;
                }
            }

            ctx.pos = start;
            if (parseNumber(text, ctx, lines)) return true;

            return false;
        }

        // <thing> (<opTerm> <thing>)*
        function parseTerm(text, ctx, lines) {
            const start = ctx.pos;

            if (!parseChain(text, ctx, lines, T_TERM, parseThing, parseOpTerm)) {
                return false;
            }

            return true;
        }

        function parseExpression(text, ctx, lines) {
            const start = ctx.pos;

            if (!parseChain(text, ctx, lines, T_EXPR, parseTerm, parseOpExpr)) {
                return false;
            }

            return true;
        }

        function parseLine(text, ctx, lines) {
            const start = ctx.pos;
            while (parseExpression(text, ctx, lines)) {}

            return start !== ctx.pos;
        }

        // return an AST-like thing
        function parseProgram(text) {
            const ctx = { pos: 0 };
            const lines = [];

            while (parseLine(text, ctx, lines)) {}

            return {
                expressions: lines
            };
        }

        function debugPrintProgram(program, text) {
            const dfs = (node) => {
                if (typeof node === "string") {
                    return;
                }
                if (typeof node.start === "number" && typeof node.end === "number") {
                    node.text = text.substring(node.start, node.end);
                    // node.val = evaluateProgram(node.text);
                    delete node.start;
                    delete node.end;
                }

                for (const k of Object.keys(node)) {
                    dfs(node[k]);
                }
            };

            dfs(program);
            return JSON.stringify(program, null, 4);
        }

        // ---- evaluating the AST
        const VT_NUMBER = debug ? "VT_NUMBER" : 0;
        const VT_ERROR = debug ? "VT_ERROR" : 1;

        function vtToString(vt) {
            switch (vt) {
                case VT_NUMBER: return "VT_NUMBER";
                case VT_ERROR: return "VT_ERROR";
            }
            return "unknown type " + vt;
        }

        function evaluateNumber(x) {
            return {
                vt: VT_NUMBER,
                val: parseFloat(x.value)
            };
        }

        // the function operator(T1, t2) can be found by doing applicatorMatrix[t1][t2][operator].
        // applicator is probably a made up word, but it sounds cool so I will keep calling it that
        const applicatorMatrix = {
            [VT_NUMBER]: {
                [VT_NUMBER]: {
                    "+": (a, b) => ({ vt: VT_NUMBER, val: a.val + b.val }),
                    "-": (a, b) => ({ vt: VT_NUMBER, val: a.val - b.val }),
                    "*" : (a, b) => ({ vt: VT_NUMBER, val: a.val * b.val }),
                    "/": (a, b) => ({ vt: VT_NUMBER, val: a.val / b.val }),
                    "%": (a, b) => ({ vt: VT_NUMBER, val: a.val % b.val })
                }
            }
        };

        function applyOperator(val, x, op) {
            const val2 = evaluateExpression(x);
            const t1 = val.vt;
            const t2 = val2.vt;

            const applicator = applicatorMatrix[t1][t2][op.value];
            if (!applicator) {
                return { vt: VT_ERROR, v: `the operator ${op.value} doesn't have a mapping from ${vtToString(t1)} -> ${vtToString(t2)}` };
            }

            return applicator(val, val2);
        }

        function evaluateChain(x) {
            let val = evaluateExpression(x.terms[0]);
            for (let i = 1; i < x.terms.length; i++) {
                val = applyOperator(val, x.terms[i], x.ops[i - 1]);
            }
            return val;
        }

        function evaluateExpression(x) {
            const type = x.t;

            switch (type) {
                case T_NUMBER:
                    return evaluateNumber(x);
                case T_EXPR:
                case T_TERM:
                    return evaluateChain(x);
                default:
                    return "Unknown ast node type";
            }
        }

        function evaluateProgram(program, text) {
            return program.expressions.map((x) => evaluateExpression(x));
        }

        // ---- actually using the parser from here on

        const input = document.getElementById("input");

        input.addEventListener("input", () => {
            rerender(input.innerText);
        });

        function recompile(text) {
            const ast = parseProgram(text);
            const output = evaluateProgram(ast, text);

            for (const i in output) {
                output[i] = JSON.stringify(output[i], null, 4);
            }
            // const output = debugPrintProgram(ast, text);

            return output; //.map((x) => x.toString()).join("\n");
        }

        function rerender(text) {
            document.getElementById("output").innerText = recompile(text);
        }

        input.innerText = "3 * (2 + (3 + 3 * (9)))";
        rerender(input.innerText);
    </script>
</html>
