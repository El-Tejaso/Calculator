<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Calculator</title>
    </head>
    <!-- // ---- styles -->
    <style>
        .flex-row {
            display: flex;
            flex-direction: row;
        }

        .label {
            max-width: 200px;
        }

        .testcase-button:hover {
            background: rgba(0,0,0,0.3);
            cursor: pointer;
        }

        .failing {
            background: rgba(255,0,0,0.5);
        }

        .passing {
            background: rgba(0,255,0,0.5);
        }

        *[hidden] {
            display: none !important;
        }

        body :focus {
            outline: none;
        }

        textarea {
            border: none;
            overflow: hidden;
            outline: none;

            margin: 0px;

            -webkit-box-shadow: none;
            -moz-box-shadow: none;
            box-shadow: none;

            resize: none; /*remove the resize handle on the bottom right*/
        }

        #line-numbers {
            color: #aaaaaa;
            background: #000000;
            outline: none;
            border-right: 1px solid #aaaaaa;
        }

        .code {
            white-space: pre;
            tab-size: 4;
            line-height: 1.4rem;
        }
        
        .code div:before {
            content: "|";
            width: 20px;
        }

        .med {
            font-size: 1.2rem;
        }

        .error {
            color: #ff0000;
        }

        th,
        td {
            outline: black solid 1px;
        }

        #testcases button {
            margin: 5px;
            display: block;
        }

        pre {
            margin: 0px;
        }

        .text-output {
            padding: 5px; 
        }

        .p-5 { padding: 5px; }
        .m-0 { margin: 0; }

        .indent-1 { margin-left: 4rem; }
        .indent-2 { margin-left: 8rem; }
        .indent-3 { margin-left: 12rem; }

        .input {
            padding-left: 5px;
            background: #000000;
            color: #ffffff;
        }

        .graph-rect {
            cursor: crosshair;
        }
    </style>
    <body style="font-family: 'Source Code Pro', monospace; margin: 0px">
        <div style="padding: 10px" class="not-zen">
            <h2>Calculator</h2>

            <div style="margin-top: 20px">
                <!-- Not intended to be an actual calculator. It is practice for creating a parser to making a
                programming language that I have been thinking about for a while now. This won't be the actual language, nor
                will it be complete, but I will try to add some cool features. I don't intend to spend any
                more than around 4 days on this site. (actually I ended up spending 2-3 weeks on it, and I will probably keep adding to it
                if I actually end up using it) -->
                <p>
                    This was originally supposed to be a simple calculator that only supported simple +-*/ operations and brackets, but I
                    got a bit carried away and now it's a programming language???
                    Type something into the box, or click on one of the examples in the table below.
                </p>
            </div>
        </div>
        <div>
            <!-- <div style="display: flex; flex-direction: row;">
                <div id="calculator-result" class="text-output" style="padding: 5px; white-space: pre; flex: 1; text-align:right;"></div>
                <div id="calculator-input" contenteditable="plaintext-only" style="padding: 5px; white-space: pre; min-height: 60px; flex: 1;"></div>
            </div> -->
            <div style="display: flex; flex-direction: row">
                <div id="line-numbers" class="code med" style="padding: 5px;"></div>
                <textarea
                    id="calculator-input"
                    class="input code med"
                    style="padding: 5px; white-space: pre; min-height: 60px; flex: 1"
                    spellcheck="false"
                ></textarea>
            </div>
            <div id="stdout"></div>
            <div class="not-zen" style="margin-top: 50px; padding: 10px">
                <button id="zen-mode" style="width: unset">Remove clutter</button>
            </div>
        </div>
        <div style="padding: 10px" class="not-zen">
            <h3 title="these are really test cases">Debugging</h3>
            <input type="checkbox" id="show-ast-checkbox" />
            <label for="show-ast-checkbox">Show AST object</label><br />
            <pre id="ast-output" style="padding: 5px"></pre>
            <input type="checkbox" id="show-result-checkbox" />
            <label for="show-result-checkbox">Show result object</label><br />
            <input type="checkbox" id="show-all-tests" />
            <label for="show-all-tests">Show every testcase</label><br />

            <pre id="result-output" style="padding: 5px"></pre>
        </div>
        <div style="padding: 10px" class="not-zen">
            <div style="margin-top: 20px">
                <h3 title="these are really test cases">Examples</h3>
                <table id="testcases" style="width: 100%"></table>
            </div>
        </div>
    </body>
    <script>
        const debug = true;
        // const debug = false;

        // ---- evaluating the AST
        // This is before the parsing code, because the parser depends on some of the structures and stuff defined here.

        const VT_ANY = debug ? "VT_ANY" : 0; // used only for type-based whatever, not a real value

        const VT_NUMBER = debug ? "VT_NUMBER" : 0;
        const VT_TENSOR = debug ? "VT_TENSOR" : 1;
        const VT_ERROR = debug ? "VT_ERROR" : 2;
        const VT_NULL = debug ? "VT_NULL" : 3;
        const VT_FUNCTION = debug ? "VT_FUNCTION" : 4;
        const VT_STRING = debug ? "VT_STRING" : 5;
        const VT_LIST = debug ? "VT_LIST" : 6;

        const RT_PRINT = "print";
        const RT_GRAPH = "graph";
        const RT_PLOT = "plot";

        function makeErr(ctx, info) {
            const err = {
                vt: VT_ERROR,
                val: info
            };
            
            ctx.errors[0] = err;

            return err;
        }

        function vtToString(vt) {
            switch (vt) {
                case VT_NUMBER: return "NUMBER";
                case VT_TENSOR: return "TENSOR";
                case VT_ERROR: return "ERROR";
                case VT_NULL: return "NULL";
                case VT_FUNCTION: return "FUNCTION";
                case VT_STRING: return "STRING";
                case VT_LIST: return "LIST";
            }
            return "unknown type " + vt;
        }

        function evaluateNumber(x) {
            return makeNumber(parseFloat(x.text));
        }

        const NULL_OBJ = { vt: VT_NULL, astNode: null };
        function makeNull() {
            return NULL_OBJ;
        }

        function makeNumber(n) {
            return { vt: VT_NUMBER, val: n, astNode: null};
        }

        function makeString(s) {
            return { vt: VT_STRING, val: s, astNode: null };
        }

        const builtInConstantsMap = {
            PI: makeNumber(Math.PI),
            E: makeNumber(Math.E),
            // golden ratio
            PHI: makeNumber(1.618033988749)
        };
        const builtInConstants = Object.keys(builtInConstantsMap);

        function hasVariable(ctx, name) {
            if(reservedKeywords.includes(name)) return true;
            if (builtInConstants.includes(name)) return true;
            if (ctx.variables.has(name)) return true;

            return false;
        }

        function getVariable(ctx, name, shouldReturnError = true) {
            if (typeof name !== "string") {
                throw new Error("You aren't calling getVariable right");
            }

            let v = builtInConstantsMap[name];
            if (v) {
                return v;
            }
            v = ctx.variables.get(name);
            if (v) {
                return v;
            }

            if (shouldReturnError) {
                return makeErr(
                    ctx,
                    `the variable ${name} hasn't been declared yet.
    You can do something like ${name} := 2; to declare it.`
                );
            }

            return null;
        }

        function evaluateVariable(ctx, x, err = true) {
            const name = x.text;
            return getVariable(ctx, name, err)
        }

        function copyTensor(a) {
            return {
                vt: VT_TENSOR,
                shape: a.shape.slice(),
                data: a.data.slice()
            };
        }

        function getMatrixStride(ctx, a, b) {
            let remainderPart = a.shape.length - b.shape.length;
            if (a.shape.length === 1 && b.shape.length === 1 && b.shape[0] === 1) {
                return 1;
            } else if(areSameShape(a.shape.slice(remainderPart), b.shape)) {
                return a.shape.slice(remainderPart).reduce((a, b) => a * b, 1);
            } else {
                return makeErr(ctx, "wrong sizes");
            }
        }

        function performElementwiseOp(ctx, a, b, op) {
            const stride = getMatrixStride(ctx, a, b);
            if (stride.vt === VT_ERROR) return stride;

            const newTensor = copyTensor(a);

            for(let i = 0; i < a.data.length; i += stride) {
                for(let j = 0; j < b.data.length; j++) {
                    newTensor.data[i + j] = op(newTensor.data[i + j], b.data[j]);
                }
            }

            return newTensor;
        }

        // the function operator(T1, t2) can be found by doing binOpMatrix[t1][t2][operator].
        const binOpMatrix = {
            [VT_NUMBER]: {
                [VT_NUMBER]: {
                    "+": (ctx, a, b) => makeNumber(a.val + b.val),
                    "<": (ctx, a, b) => makeNumber(a.val < b.val ? 1.0 : 0.0),
                    ">": (ctx, a, b) => makeNumber(a.val > b.val ? 1.0 : 0.0),
                    "<=": (ctx, a, b) => makeNumber(a.val <= b.val ? 1.0 : 0.0),
                    ">=": (ctx, a, b) => makeNumber(a.val >= b.val ? 1.0 : 0.0),
                    "==": (ctx, a, b) => makeNumber(Math.abs(a.val - b.val) < 0.0000000001 ? 1.0 : 0.0),
                    "-": (ctx, a, b) => makeNumber(a.val - b.val),
                    "*": (ctx, a, b) => makeNumber(a.val * b.val),
                    "/": (ctx, a, b) => makeNumber(a.val / b.val),
                    "%": (ctx, a, b) => makeNumber(a.val % b.val),
                    "^": (ctx, a, b) => makeNumber(Math.pow(a.val, b.val)),
                }
            },
            [VT_TENSOR]: {
                [VT_TENSOR]: {
                    "**": (ctx, a, b) => {
                        if (a.shape.length === 1 && b.shape.length === 1 && a.shape[0] === b.shape[0]) {
                            let sum = 0;
                            for(let i = 0; i < a.data.length; i++) {
                                sum += a.data[i] * b.data[i];
                            }
                            return makeNumber(sum);
                        }

                        // matrix multiplication
                        let aW = a.shape.length === 1 ? a.shape[0] : a.shape[1];
                        let bW = b.shape.length === 0 ? 1 : (b.shape[1] || 1);
                        let aH = a.shape.length === 1 ? 1 : a.shape[0];
                        let bH = b.shape.length === 1 ? b.shape[0] : b.shape[0];

                        if (a.shape.length > 2 || b.shape.length > 2) {
                            return makeErr(ctx, `matrix multiplication only works with matrices/vectors for now`);
                        }
                        if (aW !== bH) {
                            return makeErr(ctx, `second matrix row count (${bH}) must equal first matrix column count ${aW}`);
                        }

                        const newData = Array(bW * aH);

                        for(let i = 0; i < bW; i++) {
                            for(let j = 0; j < aH; j++) {
                                let dotP = 0;
                                for(let k = 0; k < bH; k++) {
                                    dotP += a.data[k + j*aW] *
                                        b.data[i + k*bW];
                                }
                                newData[i + j*bW] = dotP;
                            }
                        }

                        return {
                            vt: VT_TENSOR,
                            data: newData,
                            shape: [bW, aH]
                        };
                    },

                    "<": (ctx, a, b) => performElementwiseOp(ctx, a, b, (a, b) => a < b ? 1.0 : 0.0),
                    ">": (ctx, a, b) => performElementwiseOp(ctx, a, b, (a, b) => a > b ? 1.0 : 0.0),
                    "<=": (ctx, a, b) => performElementwiseOp(ctx, a, b, (a, b) => a <= b ? 1.0 : 0.0),
                    ">=": (ctx, a, b) => performElementwiseOp(ctx, a, b, (a, b) => a >= b ? 1.0 : 0.0),
                    "==": (ctx, a, b) => performElementwiseOp(ctx, a, b, (a, b) => Math.abs(a - b) > 0.0000000001 ? 1.0 : 0.0),
                    "+": (ctx, a, b) => performElementwiseOp(ctx, a, b, (a, b) => a + b),
                    "-": (ctx, a, b) => performElementwiseOp(ctx, a, b, (a, b) => a - b),
                    "*": (ctx, a, b) => performElementwiseOp(ctx, a, b, (a, b) => a * b),
                    "/": (ctx, a, b) => performElementwiseOp(ctx, a, b, (a, b) => a / b),
                    "%": (ctx, a, b) => performElementwiseOp(ctx, a, b, (a, b) => a % b),
                    "^": (ctx, a, b) => performElementwiseOp(ctx, a, b, (a, b) => Math.pow(a, b)),
                }
            },
            [VT_STRING]: {
                [VT_STRING]: {
                    "+": (ctx, a, b) => ({ vt: a.vt, val: a.val + b.val }),
                }
            },
            [VT_LIST]: {
                // these mutate directly
                [VT_ANY]: {
                    "+": (ctx, a, b) => { a.items.push(b); return a; },
                }
            }
        };

        function applyOperator(ctx, lhs, rhs, op) {
            const t1 = lhs.vt;
            const t2 = rhs.vt;

            let binOp = null,
                binOpL1 = null,
                binOpL2 = null;
            binOpL1 = binOpMatrix[t1] || binOpMatrix[VT_ANY];

            if (binOpL1) {
                binOpL2 = binOpL1[t2] || binOpL1[VT_ANY];
                if (binOpL2) {
                    binOp = binOpL2[op.text];
                }
            }

            if (!binOp) {
                // find the largest common shape, and try to multiply component-wise
                if (t1.vt === VT_TENSOR) {
                }

                return makeErr(
                    ctx,
                    `the operation ${vtToString(t1)} ${op.text} ${vtToString(t2)} doesn't exist yet` 
                        + ((t1 === VT_TENSOR && t2 === VT_NUMBER) || (t2 === VT_TENSOR && t1 === VT_NUMBER) ? " (hint: put [] around the number)" : "")
                );
            }

            return binOp(ctx, lhs, rhs);
        }

        function evaluateChain(ctx, x) {
            let val = evaluateExpression(ctx, x.terms[0]);
            if (val.vt === VT_ERROR) {
                return val;
            }

            for (let i = 1; i < x.terms.length; i++) {
                const val2 = evaluateExpression(ctx, x.terms[i]);
                if (val2.vt === VT_ERROR) {
                    return val;
                }

                val = applyOperator(ctx, val, val2, x.ops[i - 1]);
            }
            return val;
        }

        const unaryOpsMap = {
            [VT_NUMBER]: {
                "+": (ctx, x) => x,
                "-": (ctx, x) => ({ vt: x.vt, val: -x.val }),
            },
            [VT_TENSOR]: {
                "-": (ctx, x) => {
                    const tensor = copyTensor(x);
                    for(let i = 0; i < tensor.data.length; i++) {
                        tensor.data[i] = -tensor.data[i];
                    }
                    return tensor;
                },
                "~": (ctx, x) => {
                    if (x.shape.length > 2) {
                        // I don't have the math knowledge required to make this work for tensors,
                        // nor do I have a use case beyond matrices, so I shouldn't waste my time on getting this to work
                        return makeErr(ctx, `transposing is only defined on matrices and vectors at the moment (tensors with 1 or 2 shape components)`);
                    }

                    const tensor = copyTensor(x);

                    if (x.shape.length === 1) {
                        tensor.shape = [1, tensor.shape];
                        return tensor;
                    } 

                    // Even though you may be used to seeing width followed by height everywhere, w, h is the correct reverse order here. 
                    let w = x.shape[1];
                    let h = x.shape[0];
                    tensor.shape = [w, h];
                    for(let i = 0; i < w; i++) {
                        for(let j = 0; j < h; j++) {
                            tensor.data[i*h + j] = x.data[i + j*w]
                        }
                    }

                    return tensor;
                }
            }
        };
        const unaryOps = [];
        for (const typeKey in unaryOpsMap) {
            const opList = unaryOpsMap[typeKey];
            for (const op in opList) {
                unaryOps.push(op);
            }
        }

        function evaluateUnaryOp(ctx, x) {
            const val = evaluateExpression(ctx, x.expr);
            if (val.vt === VT_ERROR) {
                return val;
            }

            const func = unaryOpsMap[val.vt][x.op.text];
            if (!func) {
                return makeErr(ctx, `unary op ${x.op.text} can't be used on ${vtToString(val.vt)}`);
            }

            return func(ctx, val);
        }

        function getVals(args) {
            return args.map(v => v.val)
        }

        // imagine building an interpreted language in an interpreted language

        // these args are nowhere near enough to capture the way arguments are specified into these functions.
        // Some of these builtin math functions take two floats, I was just not bothered to update the args arrays.
        // Some of the methods also take variadic arguments.
        // Some of the methods also want a list of things, followed by some normal arguments. 
        //      e.g graph(...listOfFunctions, domainStart, domainEnd);
        // Some of the methods also can take an 'any' type, or some particular combination of types for an argument.
        // we basically need to implement a little regex-like function to validate the input of types given some validation object. (that is, if we don't want to manually write type validation code per-function)
        // this is not a priority at the moment, so the argument input checking will be lacking for now (and probably forever, until I make it in Rust)
        // now that I think about it, this language is a super good use-case for Rust+web-assembly. I will consider it
        const builtinFunctionsMap = {
            abs: {
                args: [{ vt: VT_NUMBER }],
                fn: (ctx, ...args) => makeNumber(Math.abs(getVals(args)))
            },
            acos: {
                args: [{ vt: VT_NUMBER }],
                fn: (ctx, ...args) => makeNumber(Math.acos(getVals(args)))
            },
            acosh: {
                args: [{ vt: VT_NUMBER }],
                fn: (ctx, ...args) => makeNumber(Math.acosh(getVals(args)))
            },
            asin: {
                args: [{ vt: VT_NUMBER }],
                fn: (ctx, ...args) => makeNumber(Math.asin(getVals(args)))
            },
            asinh: {
                args: [{ vt: VT_NUMBER }],
                fn: (ctx, ...args) => makeNumber(Math.asinh(getVals(args)))
            },
            atan: {
                args: [{ vt: VT_NUMBER }],
                fn: (ctx, ...args) => makeNumber(Math.atan(getVals(args)))
            },
            atanh: {
                args: [{ vt: VT_NUMBER }],
                fn: (ctx, ...args) => makeNumber(Math.atanh(getVals(args)))
            },
            atan2: {
                args: [{ vt: VT_NUMBER }, { vt: VT_NUMBER }],
                fn: (ctx, ...args) => makeNumber(Math.atan2(getVals(args)))
            },
            ceil: {
                args: [{ vt: VT_NUMBER }],
                fn: (ctx, ...args) => makeNumber(Math.ceil(getVals(args)))
            },
            cos: {
                args: [{ vt: VT_NUMBER }],
                fn: (ctx, ...args) => makeNumber(Math.cos(getVals(args)))
            },
            cosh: {
                args: [{ vt: VT_NUMBER }],
                fn: (ctx, ...args) => makeNumber(Math.cosh(getVals(args)))
            },
            exp: {
                args: [{ vt: VT_NUMBER }],
                fn: (ctx, ...args) => makeNumber(Math.exp(getVals(args)))
            },
            floor: {
                args: [{ vt: VT_NUMBER }],
                fn: (ctx, ...args) => makeNumber(Math.floor(getVals(args)))
            },
            hypot: {
                args: [{ vt: VT_NUMBER }],
                fn: (ctx, ...args) => makeNumber(Math.hypot(getVals(args)))
            },
            imul: {
                args: [{ vt: VT_NUMBER }],
                fn: (ctx, ...args) => makeNumber(Math.imul(getVals(args)))
            },
            log: {
                args: [{ vt: VT_NUMBER }],
                fn: (ctx, ...args) => makeNumber(Math.log(getVals(args)))
            },
            log1p: {
                args: [{ vt: VT_NUMBER }],
                fn: (ctx, ...args) => makeNumber(Math.log1p(getVals(args)))
            },
            log10: {
                args: [{ vt: VT_NUMBER }],
                fn: (ctx, ...args) => makeNumber(Math.log10(getVals(args)))
            },
            log2: {
                args: [{ vt: VT_NUMBER }],
                fn: (ctx, ...args) => makeNumber(Math.log2(getVals(args)))
            },
            max: {
                args: [{ vt: VT_NUMBER }],
                fn: (ctx, ...args) => makeNumber(Math.max(getVals(args)))
            },
            min: {
                args: [{ vt: VT_NUMBER }],
                fn: (ctx, ...args) => makeNumber(Math.min(getVals(args)))
            },
            pow: {
                args: [{ vt: VT_NUMBER }, { vt: VT_NUMBER }],
                fn: (ctx, ...args) => makeNumber(Math.pow(getVals(args)))
            },
            random: {
                args: [{ vt: VT_NUMBER }],
                fn: (ctx, ...args) => makeNumber(Math.random(getVals(args)))
            },
            round: {
                args: [{ vt: VT_NUMBER }],
                fn: (ctx, ...args) => makeNumber(Math.round(getVals(args)))
            },
            sign: {
                args: [{ vt: VT_NUMBER }],
                fn: (ctx, ...args) => makeNumber(Math.sign(getVals(args)))
            },
            sin: {
                args: [{ vt: VT_NUMBER }],
                fn: (ctx, ...args) => makeNumber(Math.sin(getVals(args)))
            },
            sinh: {
                args: [{ vt: VT_NUMBER }],
                fn: (ctx, ...args) => makeNumber(Math.sinh(getVals(args)))
            },
            sqrt: {
                args: [{ vt: VT_NUMBER }],
                fn: (ctx, ...args) => makeNumber(Math.sqrt(getVals(args)))
            },
            tan: {
                args: [{ vt: VT_NUMBER }],
                fn: (ctx, ...args) => makeNumber(Math.tan(getVals(args)))
            },
            tanh: {
                args: [{ vt: VT_NUMBER }],
                fn: (ctx, ...args) => makeNumber(Math.tanh(getVals(args)))
            },
            trunc: {
                args: [{ vt: VT_NUMBER }],
                fn: (ctx, ...args) => makeNumber(Math.trunc(getVals(args)))
            },

            // ---- builtins I had to write myself

            T: {
                args: [{ vt: VT_NUMBER }],
                fn: (ctx, ...args) => ({
                    vt: VT_TENSOR,
                    data: Array(args.map((x) => x.val).reduce((prev, next) => prev * next, 1)).fill(0),
                    shape: args.map((x) => x.val)
                }) // no error checks? TODO: add. later, of
            },
            I: {
                args: [{ vt: VT_NUMBER }],
                fn: (ctx, size) => {
                    const tensor = builtinFunctionsMap.T.fn(ctx, size, size);
                    for(let i = 0; i < size.val; i++) {
                        tensor.data[i + size.val * i] = 1;
                    }
                    return tensor;
                }
            },
            toVec: {
                args: [{ vt: VT_LIST }],
                fn: (ctx, list) => {
                    for(let i = 0; i < list.items.length; i++) {
                        if (list.items[i].vt !== VT_NUMBER) {
                            return makeErr(`all items in the list must be of type ` + vtToString(VT_NUMBER));
                        }
                    }

                    let arr = Array(list.items.length);
                    for(let i = 0; i < list.items.length; i++) {
                        arr[i] = list.items[i].val;
                    }

                    return {
                        vt: VT_TENSOR,
                        data: arr,
                        shape: [arr.length]
                    };
                }
            },
            len: {
                args: [],
                fn: (ctx, x) => {
                    if (x.vt === VT_LIST) return makeNumber(x.items.length);
                    if (x.vt === VT_TENSOR) return makeNumber(x.shape[0]);
                    if (x.vt === VT_STRING) return makeNumber(x.val.length);
                    return makeErr(ctx, `can't take the length of type ${vtToString(x.vt)}`);
                }
            },

            lerp: {
                args: [{ vt: VT_NUMBER }],
                fn: (ctx, start, end, t) => makeNumber(lerp(start, end, t))
            },

            // prints a number of minutes as hours and minutes. 
            toHm: {
                args: [{ vt: VT_NUMBER}],
                fn: (ctx, v) => makeString(`${Math.floor(v.val / 60)}h ${v.val % 60}m`)
            },
            dot: {
                args: [{vt: VT_TENSOR}, {vt: VT_TENSOR}],
                fn: (ctx, a, b) => {
                    if (!areSameShape(a.shape, b.shape)) {
                        return makeErr(ctx, `two tensors must have the same shape for a dot product`)
                    }

                    let sum = 0;
                    for(let i = 0; i < a.data.length; i++) {
                        sum += a.data[i] + b.data[i];
                    }
                    return makeNumber(sum);
                }
            },

            // output functions
            print: {
                args: [],
                fn: (ctx, thing, title) => {
                    ctx.results.push({
                        rt: RT_PRINT,
                        val: thing,
                        title: (title && title.val) || (thing.astNode && thing.astNode.t === T_IDENT && thing.astNode.text),
                    });
                    return makeNull();
                }
            },
            graph: {
                args: [],
                fn: (ctx, ...args) => {
                    let functions = [];
                    let i = 0;
                    if (args[i].vt === VT_LIST) {
                        args = [...args[i].items, ...args.slice(1)];
                    }

                    for(;i < args.length; i++) {
                        if (args[i].vt !== VT_FUNCTION) break;
                        if (args[i].args.length !== 1) return makeErr(ctx, `a function can only have 1 argument to be graphable, for now at least`);
                        functions.push(args[i]);
                    }

                    if (functions.length === 0) {
                        return makeErr(ctx, `arguments to graph are like ...functions, domainStart, domainEnd`);
                    }
                    if (i !== args.length - 2) {
                        return makeErr(ctx, `specify the start and end after the list of functions`);
                    }

                    ctx.results.push({
                        rt: RT_GRAPH,
                        functions: functions,
                        start: args[i],
                        end: args[i+1]
                    });
                    return makeNull();
                }
            }
        };
        const builtinFunctions = Object.keys(builtinFunctionsMap);

        function evaluateUserDefFunctionCall(ctx, x, name) {
            const func = ctx.variables.get(name);
            if (!func) {
                return makeErr(ctx, `function '${name}' not found`);
            }
            if (func.vt !== VT_FUNCTION) {
                return makeErr(ctx, `'${name}' is not a function that can be called`);
            }

            if (x.args.length !== func.args.length) {
                return makeErr(ctx, `user defined function ${name} wants ${func.args.length} arguments, only ${x.args.length} were provided`);
            }

            const argumentNames = func.args;
            const argumentValues = x.args;

            ctx.variables.pushStackFrame();

            // set arguments to values
            for (let i = 0; i < argumentNames.length; i++) {
                const val = evaluateExpression(ctx, argumentValues[i]);
                if (val.vt === VT_ERROR) {
                    return val;
                }
                ctx.variables.set(ctx, argumentNames[i], val, ASSIGN_DECLARE);
            }

            // set captures to values
            for (let i = 0; i < func.captures.length; i++) {
                ctx.variables.set(ctx, func.captures[i][0], func.captures[i][1], ASSIGN_DECLARE);
            }

            const val = evaluateBlock(ctx, func.body);;


            ctx.variables.popStackFrame();

            return val;
        }

        function evaluateExprArray(ctx, exprs) {
            const argsEvaluated = Array(exprs.length)
            for(let i = 0; i < exprs.length; i++) {
                const val = evaluateExpression(ctx, exprs[i]);
                if (val.vt === VT_ERROR) {
                    return val;
                }
                argsEvaluated[i] = val;
            }

            return argsEvaluated;
        }

        function evaluateFunctionCall(ctx, x) {
            const name = x.name.text;
            const func = builtinFunctionsMap[name];
            if (!func) {
                // user defined funciton
                return evaluateUserDefFunctionCall(ctx, x, name);
            }

            const argsEvaluated = evaluateExprArray(ctx, x.args);
            if (argsEvaluated.vt === VT_ERROR) {
                return argsEvaluated;
            }

            // I don't care if the argument counts don't match at the moment.
            // some of the javascript math functions might accept variadic ...args,
            // and it is more important that I am able to use that than it is that I get errors about argument counts
            // at the moment.

            for (let i = 0; i < func.args.length; i++) {
                if (argsEvaluated[i].vt !== func.args[i].vt) {
                    if (argsEvaluated[i].vt === VT_ERROR) {
                        return argsEvaluated[i];
                    }

                    return makeErr(
                        ctx,
                        `Argument ${i} to function ${name} was of type ${vtToString(
                            argsEvaluated[i].vt
                        )}, but it wants ${vtToString(func.args[i].vt)}`
                    );
                }
            }

            return func.fn(ctx, ...argsEvaluated);
        }

        function evaluateFunctionAssignment(ctx, x, varName) {
            const fn = x.lhs;
            varName = fn.name.text;
            let argNames = Array(fn.args.length);
            for(let i = 0; i < fn.args.length; i++) {
                if (fn.args[i].t !== T_IDENT) {
                    return makeErr(`declaration of function ${varName} accepts an invalid variable: '${nodeText(ctx, fn.args[i])}' (hint: just use a simpler name, like 'x' or something)`);
                }

                argNames[i] = fn.args[i].text;
            }

            const body = x.rhs.t === T_BLOCK ? x.rhs : {
                t: T_BLOCK, 
                body: [x.rhs]
            };

            // our function may also be referencing variables outside of itself. 
            // in that case, we need to capture their values as they are now, and then use them when we call
            // the function again later with the given arguments. 
            // I believe this will make the most sense in the most cases. Except when they point to references, which may or may not
            // be in scope. hmm. certainly modifying a value would be questionable. it would affect how the other functions are called,
            // because they may also be referencing the same thing.
            // I wonder if this can be used to interesting effect though

            // array of pairs like [[name, val], ...]
            const captures = [];

            const dfs = (node) => {
                if (typeof node === "string" || node === null || node === undefined) {
                    return;
                }
                if (typeof node !== "object") {
                    return;
                }

                if (node.t === T_IDENT) {
                    if (argNames.includes(node.text)) return;

                    if (!captures.find(x => x[0] === node.text)) {
                        const val = evaluateVariable(ctx, node, false);
                        if (val === null) {
                            // ignore errors, they are usually from identifiers not being defined
                            return;
                        }

                        // push a copy
                        if (val.vt === VT_TENSOR) {
                            captures.push([node.text, copyTensor(val)]);
                        } else if (val.vt === VT_NUMBER) {
                            captures.push([node.text, makeNumber(val.val)]);
                        } else {
                            // push a reference (!!!)
                            captures.push([node.text, val]);
                        }
                    }
                    return;
                }

                for (const k of Object.keys(node)) {
                    if (node.t === T_ASSIGNMENT && k === "lhs") {
                        // skip all variable assignments. we don't want to treat y in f(x) { y := 2 } as a capture
                        continue;
                    }

                    dfs(node[k]);
                }
            };

            dfs(x.rhs);

            const func = {
                vt: VT_FUNCTION,
                args: argNames,
                captures: captures,
                randomNumber: Math.random(),
                body: body,
                text: nodeText(ctx, x),
                name: varName,
            };

            ctx.variables.set(ctx, varName, func, x.assignType);

            return func;
        }

        // TODO: split up function to variable assignment, indexation assignment and function assignment
        function evaluateAssignment(ctx, x) {
            let varName = null;
            let isIndexation = false;
            if (x.lhs.t === T_FUNCTION_CALL) {
                return evaluateFunctionAssignment(ctx, x);
            }

            if (x.lhs.t === T_IDENT) {
                varName = x.lhs.text;
            } else if (x.lhs.t === T_EXPR_INDEXATION && x.lhs.expr.t === T_IDENT) {
                varName = x.lhs.expr.text;
                isIndexation = true;
            } else {
                return makeErr(ctx, `can't assign to lhs type ${x.lhs.t}`);
            }

            // check if variable can be assigned to
            if (!varName) {
                return makeErr(ctx, `identifier was blank`);
            }
            if (builtinFunctions.includes(varName)) {
                return makeErr(
                    ctx,
                    Math.random() < 0.05
                        ? `NOO!!! you cant just redeclare functions !!!`
                        : `a builtin function already exists with this name`
                );
            }

            const rhs = evaluateExpression(ctx, x.rhs);
            if (rhs.vt === VT_ERROR) {
                return rhs;
            }
            const existingVar = getVariable(ctx, varName, false);

            if (isIndexation) {
                if (x.assignType === ASSIGN_DECLARE) {
                    return makeErr(ctx, `${ctx.text.substring(x.start, x.end)} - can't declare a new variable inside a thing, doesn't make sense conceptually (hint: just use '=')`);
                }
            }
            // assignType will always be not be ASSIGN_DECLARE when isIndexation is true from here on

            if (isIndexation) {
                if (x.assignType === ASSIGN_DECLARE) {
                    return makeErr(ctx, `can't declare a new variable inside a tensor, doesn't make sense conceptually (hint: just use '=')`);
                }

                // we are going to set the values directly in the tensor
                const tensor = existingVar;

                const indexes = evaluateExprArray(ctx, x.lhs.indexes);
                if (indexes.vt === VT_ERROR) {
                    return indexes;
                }

                const [flattenedIndices, remainingShape, err] = evaluateIndicesToFlatArray(ctx, x, tensor.shape, indexes);
                if (err !== null) {
                    return err;
                }

                // the thing we're assigning to should have the same shape (at some level at least)
                if (remainingShape.length === 0) {
                    if (rhs.vt === VT_TENSOR) {
                        if (flattenedIndices.length !== rhs.data.length) {
                            return makeErr(ctx, `rhs of ${nodeText(ctx, x)} needs the same number of elements as indices (${flattenedIndices.length}), instead ${rhs.data.length} were provided`)
                        }

                        for(let i = 0; i < flattenedIndices.length; i++) {
                            tensor.data[flattenedIndices[i]] = rhs.data[i];
                        }
                    } else if (rhs.vt === VT_NUMBER) {
                        for(let i = 0; i < flattenedIndices.length; i++) {
                            tensor.data[flattenedIndices[i]] = rhs.val;
                        }
                    } else {
                        return makeErr(ctx, `rhs must be a number or tensor`)
                    }
                } else {
                    if (rhs.vt !== VT_TENSOR) {
                        return makeErr(ctx, `rhs must be a tensor`);
                    }

                    if (!areSameShape(rhs.shape, remainingShape)) {
                        return makeErr(ctx, `rhs must be a tensor with shape ` + remainingShape.join("x"));
                    }

                    // we can do this, because rhs is the same shape as the remaining tensor
                    for(let i = 0; i < flattenedIndices.length; i++) {
                        for(let j = 0; j < rhs.data.length; j++) {
                            tensor.data[flattenedIndices[i] + j] = rhs.data[j];
                        }
                    }
                }

                return rhs;
            };


            let setError = ctx.variables.set(ctx, varName, rhs, x.assignType);
            if (setError !== null) {
                return setError;
            }

            return rhs;
        }

        function isTrue(x) {
            return x.vt === VT_NUMBER && x.val >= 0.5;
        }

        function evaluateTernary(ctx, x) {
            const condition = evaluateExpression(ctx, x.conditional);
            if (condition.vt === VT_ERROR) {
                return condition.vt;
            }

            if (condition.vt !== VT_NUMBER) {
                return makeErr(
                    ctx,
                    `condition needs to be a number, anything less than 0.5 is false, anything >= 0.5 is true`
                );
            }

            if (isTrue(condition)) {
                return evaluateExpression(ctx, x.ifTrue);
            }

            return evaluateExpression(ctx, x.else);
        }

        // takes in two shapes, not two tensors
        function areSameShape(s1, s2) {
            if (s1.length !== s2.length) return false;

            for (const i in s1) {
                if (s1[i] !== s2[i]) return false;
            }

            return true;
        }

        function nodeText(ctx, node) {
            return ctx.text.substring(node.start, node.end).trim();
        }

        function evaluateTensor(ctx, x) {
            const depthFirstEvalTensor = (x) => {
                if (x.t !== T_TENSOR) {
                    const val = evaluateExpression(ctx, x);
                    if (val.vt === VT_ERROR) {
                        return val;
                    }

                    if (val.vt === VT_NUMBER || val.vt === VT_TENSOR) {
                        return val;
                    }

                    return makeErr(
                        ctx,
                        `bottom level item ${nodeText(ctx, x)} in tensor not of correct type - ${vtToString(val.vt)}`
                    );
                }

                const tensor = {
                    vt: VT_TENSOR,
                    data: [],
                    shape: []
                };

                let expectedShape = null;
                for (let i = 0; i < x.rows.length; i++) {
                    let row = depthFirstEvalTensor(x.rows[i]);
                    if (row.vt === VT_ERROR) {
                        return row;
                    }

                    if (row.vt === VT_TENSOR) {
                        if (expectedShape === null) {
                            expectedShape = row.shape;
                        } else if (!areSameShape(expectedShape, row.shape)) {
                            return makeErr(
                                ctx,
                                `one of the elements of the tensor was the wrong size: ${nodeText(ctx, x.rows[i])}`
                            );
                        }

                        tensor.data.push(...row.data);
                    } else if (row.vt === VT_NUMBER) {
                        expectedShape = [];
                        tensor.data.push(row.val);
                    }
                }

                tensor.shape = [x.rows.length, ...expectedShape];

                return tensor;
            };

            const tensor = depthFirstEvalTensor(x);

            return tensor;
        }

        function evaluateIndicesToFlatArray(ctx, errorNode, shape, indexes) {
            const strides = Array(shape.length);

            // at each level, we should know how big the stride is.
            // we calculate this with a cumulative sum. at the lowest level, the stride is 1.
            // if we have a 2x3 matrix, the things would be [6, 3, 1], with 6 being the total number of things in
            // the entire matrix and hence not very useful
            strides[strides.length - 1] = 1;
            for (let i = shape.length - 2; i >= 0; i--) {
                strides[i] = shape[i + 1] * strides[i + 1];
            }

            // now, we have some indices that need to become a list of indexes.
            // if we have [1,2,3][1], then 1 is the index.
            // if we have [1,2,3][[1, 2]], then we really want 2 indices - 1 and two.
            // [[1,2,3],[4,5,6]][1][0] -> 3 + 0
            // [[1,2,3],[4,5,6]][[0, 1]][0] -> [0 + 0, 3 + 0]
            const flatIndexes = [0];
            let i = 0;
            while(i < indexes.length) { // incrementing i is done on a type by type basis. it is basically the current 'dimension'
                const idx = indexes[i];
                if (idx.vt === VT_NUMBER) {
                    for (let j = 0; j < flatIndexes.length; j++) {
                        if (idx.val < 0 || idx.val >= shape[i]) {
                            return [null, null, makeErr(ctx, `index ${idx.val} in ${nodeText(ctx, errorNode)} was out of bounds`)];
                        }
                        
                        flatIndexes[j] += strides[i] * idx.val;
                    }
                    i++;
                } else if (idx.vt === VT_TENSOR) {
                    let isListOfVectors = idx.shape.length === 2;
                    let isListOfNumbers = idx.shape.length === 1;
                    if (!isListOfNumbers && !isListOfVectors) {
                        return [null, null, makeErr(ctx,`only numbers, lists of numbers, or lists of vectors can be used as indices. \n\t(Note that this doesn't include vectors, as they can be misconstrued as a list of numbers. You will need to wrap your vector in a list)`)];
                    }

                    // copy the indices we already have for each index specified
                    let originalLen = flatIndexes.length;
                    let numIndices = isListOfNumbers ? idx.data.length : idx.shape[0];
                    for (let j = 0; j < numIndices - 1; j++) {
                        flatIndexes.push(...flatIndexes.slice(0, originalLen));
                    }

                    if (isListOfNumbers) {
                        for (let j = 0; j < numIndices; j++) {
                            // bounds check
                            if (idx.data[j] < 0 || idx.data[j] >= shape[i]) {
                                return [null, null, makeErr(ctx, `index ${idx.data[j]} in ${nodeText(ctx, errorNode)} was out of bounds`)];
                            }
    
                            // TODO: better comment
                            // increment the index by the current dimension
                            for (let k = 0; k < originalLen; k++) {
                                flatIndexes[j * originalLen + k] += strides[i] * idx.data[j];
                            }
                        }
                        i++;
                    } else {
                        const vecSize = idx.shape[1];
                        if (i + vecSize > shape.length) {
                            return [null, null, makeErr(ctx, `the indexing part of ${nodeText(ctx, errorNode)} has too many dimensions`)];
                        }

                        for(let j = 0; j < numIndices; j++) {
                            for (let k = 0; k < originalLen; k++) {
                                // we have a point or something, we need to advance the dimension by the length of this thing at the end
                                for (let dimOffset = 0; dimOffset < vecSize; dimOffset++) {
                                    // bounds check
                                    if (idx.data[j] < 0 || idx.data[j] >= shape[i]) {
                                        return [null, null, makeErr(ctx, `index ${idx.data[j]} in ${nodeText(ctx, errorNode)} was out of bounds`)];
                                    }
                                }
                                
                                for (let dimOffset = 0; dimOffset < vecSize; dimOffset++) {
                                    flatIndexes[j * originalLen + k] += strides[i + dimOffset] * idx.data[j * vecSize + dimOffset];
                                }
                            }
                        }

                        i += vecSize;
                    }

                } else {
                    return [null, null, makeErr(ctx, `tf kinda type is this huh: ${vtToString(idx.vt)}`)]
                }
            }

            return [flatIndexes, shape.slice(i), null];
        }

        function evaluateIndexation(ctx, x) {
            const expr = evaluateExpression(ctx, x.expr);
            if (expr.vt === VT_ERROR) {
                return expr;
            }

            if (expr.vt !== VT_TENSOR && expr.vt !== VT_LIST) {
                return makeErr(ctx, `the type ${vtToString(expr.vt)} cannot be indexed yet`);
            }

            const indexes = evaluateExprArray(ctx, x.indexes);
            if (indexes.vt === VT_ERROR) {
                return indexes;
            }

            if (expr.vt === VT_LIST) {
                if (indexes.length === 1) {
                    return expr.items[Math.floor(indexes[0].val)];
                } else {
                    // TODO: extract indexing logic to custom function, call it here
                    return makeErr(ctx, `can't index thing inside a thing yet :(`);
                }
            }

            const [flatIndices, remainingShape, err] = evaluateIndicesToFlatArray(ctx, x, expr.shape, indexes);
            if (err !== null) {
                return err;
            }


            if (remainingShape.length === 0) {
                for(let i = 0; i < flatIndices.length; i++) {
                    flatIndices[i] = expr.data[flatIndices[i]];
                }

                if (flatIndices.length === 1) {
                    return makeNumber(flatIndices[0])
                }

                return {
                    vt: VT_TENSOR,
                    shape: [flatIndices.length],
                    data: flatIndices,
                }
            }

            // note to self: this kind of code is FAR easier to write when in the zone than it is to read,
            // don't be discouraged if you don't understand a word of it. Kinda like regex actually
            const stride = remainingShape.reduce((a, b) => a * b, 1);
            const largerArray = Array(flatIndices.length * stride);
            for(let i = 0; i < flatIndices.length; i++) {
                for(let j = 0; j < stride; j++) {
                    largerArray[i * stride + j] = expr.data[flatIndices[i] + j];
                }
            }

            return {
                vt: VT_TENSOR,
                shape: [...remainingShape],
                data: largerArray
            };
        }

        // this does not push or pop any stack frames, they need to be done by the caller
        function evaluateBlock(ctx, x) {
            // it is a custom user defined function.
            // we will just return the final value it calculated.
            // (this could simply by a variable on it's own on a single line, so no problems here)
            let lastStatementResult = makeNull();

            // evaluate function
            for(let i = 0; i < x.body.length; i++) {
                lastStatementResult = evaluateExpression(ctx, x.body[i]);
                if (lastStatementResult.vt === VT_ERROR) {
                    return lastStatementResult;
                }
            }

            return lastStatementResult;
        }

        function evaluateForLoop(ctx, x) {
            ctx.variables.pushStackFrame();

            // initialize loop
            for(let i = 0; i < x.initializers.length; i++) {
                const val = evaluateExpression(ctx, x.initializers[i]);
                if (val.vt === VT_ERROR) {
                    return val;
                }
            }

            let maxLoopCount = 1000000, safetyCounter = 0;

            // drive loop
            for(;safetyCounter < maxLoopCount;
                safetyCounter++ // make sure we can't get any infinite loops even if we want to. I don't know how to allow users to break them yet
            ) {
                // evaluate loop condition
                const val = evaluateExpression(ctx, x.loopCondition);
                if (val.vt === VT_ERROR) {
                    return val;
                }

                if (!isTrue(val)) {
                    break;
                }

                ctx.variables.pushStackFrame();

                // loop body
                evaluateBlock(ctx, x.loopBody, false);

                ctx.variables.popStackFrame();

                // increment
                for(let i = 0; i < x.iterators.length; i++) {
                    const val = evaluateExpression(ctx, x.iterators[i]);
                    if (val.vt === VT_ERROR) {
                        return val;
                    }
                }
            }

            ctx.variables.popStackFrame();

            if (safetyCounter === maxLoopCount) {
                return makeErr(ctx, `you may have an infinite loop in your program - they are very easy to run into, which is why I have a limiter of 1,000,000 iterations per loop for now`);
            }

            return makeNull();
        }

        function evaluateString(x) {
            return makeString(x.text);
        }

        function evaluateList(ctx, x) {
            const exprs = evaluateExprArray(ctx, x.items);
            if(exprs.vt === VT_ERROR) {
                return exprs;
            }

            return {
                vt: VT_LIST,
                items: exprs
            };
        }

        function evaluateExpression(ctx, x) {
            if (!x) {
                throw new Error("expression not defined");
            }

            const type = x.t;
            let value;

            switch (type) {
                case T_NUMBER:
                    value = evaluateNumber(x);
                    break;
                case T_STRING:
                    value = evaluateString(x);
                    break;
                case T_BLOCK:
                    ctx.variables.pushStackFrame();
                    value = evaluateBlock(ctx, x);
                    ctx.variables.popStackFrame();
                    break;
                case T_BUILTIN_CONSTANT:
                case T_IDENT:
                    value = evaluateVariable(ctx, x);
                    break;
                case T_EXPR_INDEXATION:
                    value = evaluateIndexation(ctx, x);
                    break;
                case T_EXPR:
                case T_TERM:
                case T_COMPARISON:
                    value = evaluateChain(ctx, x);
                    break;
                case T_UNARY_OP:
                    value = evaluateUnaryOp(ctx, x);
                    break;
                case T_FUNCTION_CALL:
                    value = evaluateFunctionCall(ctx, x);
                    break;
                case T_ASSIGNMENT:
                    value = evaluateAssignment(ctx, x);
                    break;
                case T_TERNARY:
                    value = evaluateTernary(ctx, x);
                    break;
                case T_TENSOR:
                    value = evaluateTensor(ctx, x);
                    break;
                case T_FOR_LOOP:
                    value = evaluateForLoop(ctx, x);
                    break;
                case T_LIST:
                    value = evaluateList(ctx, x);
                    break;
                default:
                    value = makeErr(ctx, "Unknown ast node type: " + type);
                    break;
            }

            if (typeof value === "object" && value !== null) {
                value.astNode = x;
            }

            return value;
        }


        // a stack of hashmaps to keep track of scopes. 
        // the hashmaps are pooled, because that is probably more efficient than
        // appending and popping a new map from an array a thousand times
        class ScopeStack {
            constructor() {
                this.scopes = [new Map()];
                this.currentScope = 0;
            }
            pushStackFrame() {
                if (this.currentScope === this.scopes.length - 1) {
                    this.scopes.push(new Map());
                }

                this.currentScope++;
                this.scopes[this.currentScope].clear();
            }
            popStackFrame() {
                this.currentScope--;
            }
            has(key) {
                for(let i = this.currentScope; i >= 0; i--) {
                    if (this.scopes[i].has(key)) {
                        return true;
                    }
                }

                return false;
            }
            get(key) {
                for(let i = this.currentScope; i >= 0; i--) {
                    if (this.scopes[i].has(key)) {
                        return this.scopes[i].get(key);
                    }
                }

                return null;
            }
            set(ctx, key, value, assignType) {
                // if declaration, create variable in local scope
                if (assignType === ASSIGN_DECLARE) {
                    const currentScope = this.scopes[this.currentScope];
                    if (currentScope.has(key)) 
                        return makeErr(ctx, `variable ${key} already defined, with value: ${valueToString(currentScope.get(key))}`);
                        
                    currentScope.set(key, value);
                    return null;
                }

                if (assignType === ASSIGN_INCREMENT) {
                    const existing = this.get(key);
                    value = applyOperator(ctx, existing, value, { text: "+" });
                } else if (assignType === ASSIGN_DECREMENT) {
                    const existing = this.get(key);
                    value = applyOperator(ctx, existing, value, { text: "-" });
                }
                
                // set variable in whatever scope it is in
                for (let i = this.currentScope; i >= 0; i--) {
                    if (!this.scopes[i].has(key)) continue;
                    
                    this.scopes[i].set(key, value);
                    return null;
                }

                return makeErr(ctx, `couldn't set ${key}, it wasn't found anywhere`);
            }
        }

        function evaluateProgram(program, text) {
            const ctx = {
                variables: new ScopeStack(),
                errors: [],
                results: [],
                programResult: makeNull(),
                text: text
            };

            if (program.parseError) {
                ctx.programResult = makeErr(ctx, program.parseError);
                return ctx;
            }
            
            for(let i = 0; i < program.expressions.length; i++) {
                ctx.programResult = evaluateExpression(ctx, program.expressions[i]);
                if (ctx.programResult === VT_ERROR) {
                    break;
                }
            }
            try {
            } catch(err) {
                ctx.programResult = makeErr(ctx, `A Javascript error occurred while evaluating your program: ${err}`);
            }

            return ctx;
        }

        // not a particularly good visualisation. TODO: improve
        function tensorToString(t) {
            if (t.vt !== VT_TENSOR) {
                return valueToString(t);
            }

            let counter = 0;
            const dfs = (level) => {
                if (level === t.shape.length) {
                    let val = t.data[counter];
                    counter++;
                    return val;
                }

                let stringBuilder = [];
                for (let i = 0; i < t.shape[level]; i++) {
                    let str = dfs(level + 1);
                    if (i > 0) {
                        str = " " + str;
                    }
                    stringBuilder.push(str);
                }

                const joinStr = level === t.shape.length - 1 ? ", " : ", \n";
                return "[" + stringBuilder.join(joinStr) + "]";
            };

            let dataStr = dfs(0);

            return "shape: " + t.shape.join("x") + ", data: \n" + dataStr.replace(/\n/g, "\n\t");
        }

        function valueToString(v) {
            if(!v) {
                return "{}";
            }

            switch (v.vt) {
                case VT_NULL:
                    return "{}";
                case VT_TENSOR:
                    return tensorToString(v).replace("\n", "\n\t");
                case VT_NUMBER:
                    return v.val.toString();
                case VT_STRING:
                    return v.val;//"\"" + v.val.toString().replace(/"/g, "\\\"") + "\"";
                case VT_FUNCTION:
                    return v.text + (v.captures.length === 0 ? "" : " where " + v.captures.map(x => x[0] + "=" + valueToString(x[1])).join(", "));
                case VT_LIST:
                    return "<" + v.items.map(i => valueToString(i)).join(",\n") + ">";
                default:
                    return `${v.val}`;
            }
        }

        function thingToString(v) {
            let type = vtToString(v.vt);
            let str = valueToString(v);

            return `[${type}] ${str}`;
        }

        // ---- parser

        const T_EXPR = debug ? "T_EXPR" : 0;
        const T_NUMBER = debug ? "T_NUMBER" : 1;
        const T_OP_EXPR = debug ? "T_OP_EXPR" : 2;
        const T_OP_TERM = debug ? "T_OP_TERM" : 3;
        const T_TERM = debug ? "T_TERM" : 4;
        const T_BUILTIN_CONSTANT = debug ? "T_BUILTIN_CONSTANT" : 5;
        const T_UNARY_OP = debug ? "T_UNARY_OP" : 6;
        const T_IDENT = debug ? "T_IDENT" : 7; // arbitrary text, could be anything.
        const T_FUNCTION_CALL = debug ? "T_FUNCTION_CALL" : 8;
        const T_OP_EXPONENT = debug ? "T_OP_EXPONENT" : 9;
        const T_ASSIGNMENT = debug ? "T_ASSIGNMENT" : 10;
        const T_TERNARY = debug ? "T_TERNARY" : 11;
        const T_TENSOR = debug ? "T_TENSOR" : 12;
        const T_EXPR_INDEXATION = debug ? "T_EXPR_INDEXATION" : 13;
        const T_FOR_LOOP = debug ? "T_FOR_LOOP" : 14;
        const T_BLOCK = debug ? "T_BLOCK" : 15;
        const T_STRING = debug ? "T_STRING" : 16;
        const T_OP_COMPARISON = debug ? "T_OP_COMPARISON" : 17;
        const T_COMPARISON = debug ? "T_COMPARISON" : 18;
        const T_LIST = debug ? "T_LIST" : 19;

        const reservedKeywords = [
            "for"
        ];


        // Thankyou Trevor https://stackoverflow.com/questions/1496826/check-if-a-single-character-is-a-whitespace
        function isWhitespace(c) {
            return (
                c === " " ||
                c === "\n" ||
                c === "\t" ||
                c === "\r" ||
                c === "\f" ||
                c === "\v" ||
                c === "\u00a0" ||
                c === "\u1680" ||
                c === "\u2000" ||
                c === "\u200a" ||
                c === "\u2028" ||
                c === "\u2029" ||
                c === "\u202f" ||
                c === "\u205f" ||
                c === "\u3000" ||
                c === "\ufeff"
            );
        }

        function isDigit(c) {
            return (
                c === "1" ||
                c === "2" ||
                c === "3" ||
                c === "4" ||
                c === "5" ||
                c === "6" ||
                c === "7" ||
                c === "8" ||
                c === "9" ||
                c === "0"
            );
        }

        function isLetter(c) {
            return c.toUpperCase() != c.toLowerCase() || c.codePointAt(0) > 127 || c === "_";
        }

        // this code also parses comments.
        // This way, comments can appear almost anywhere in the
        function advanceWhileWhitespace(text, pos) {
            if (debug) {
                if (typeof text !== "string") {
                    throw new Error("you might be calling advanceWhileWhitespace wrong");
                }
            }

            while (
                pos < text.length &&
                (isWhitespace(text[pos]) || (text[pos] === "/" && text[pos + 1] === "/"))
            ) {
                // single line comment, ignore all text on the same line after //.
                // TODO: figure out how we can actually store these comments and use them
                // in a meaningful way
                if (text[pos] === "/") {
                    pos += 2;
                    while (pos < text.length && text[pos] !== "\n") {
                        pos++;
                    }
                }

                pos++;
            }
            return pos;
        }

        function hasText(text, pos, comp) {
            if (pos + comp.length > text.length) {
                return false;
            }

            return text.substring(pos, pos + comp.length) === comp;
        }

        // parses one of some array possible delimiters. oneOfWhat is an array of possible strings.
        // It is important that the delimiters are arranged in order of longest to shortest.
        // If you pass in ["<", "<="] and we have "<=" in the string, we won't get to it because we also have "<".
        function parseOneOf(text, ctx, lines, possibleDelimiters, type) {
            const pos = advanceWhileWhitespace(text, ctx.pos);
            ctx.pos = pos;

            for (let i in possibleDelimiters) {
                const end = pos + possibleDelimiters[i].length;
                if (!hasText(text, pos, possibleDelimiters[i])) {
                    continue;
                }

                ctx.pos = end;
                lines.push({
                    t: type,
                    start: pos,
                    end: end,
                    text: text.substring(pos, end)
                });
                return true;
            }

            return false;
        }

        function parseOpComparison(text, ctx, ops) {
            return parseOneOf(text, ctx, ops, [">=", "<=", "==", ">", "<"], T_OP_COMPARISON);
        }

        // operators with the same precedence as addition
        function parseOpExpr(text, ctx, ops) {
            return parseOneOf(text, ctx, ops, ["+", "-"], T_OP_EXPR);
        }

        // one of *, /, %
        function parseOpTerm(text, ctx, ops) {
            return parseOneOf(text, ctx, ops, ["**", "*", "/", "%", "^"], T_OP_TERM);
        }

        // one of ^
        function parseOpExponent(text, ctx, ops) {
            return parseOneOf(text, ctx, ops, ["^"], T_OP_EXPONENT);
        }

        // operators with the same precedence as multiplication
        function parseNumber(text, ctx, lines) {
            const start = advanceWhileWhitespace(text, ctx.pos);
            if (start >= text.length) {
                return false;
            }
            ctx.pos = start;

            if (!isDigit(text[ctx.pos])) return false;

            let foundDecimal = false;
            while (ctx.pos < text.length && (isDigit(text[ctx.pos]) || (!foundDecimal && text[ctx.pos] === "."))) {
                if (text[ctx.pos] === ".") {
                    foundDecimal = true;
                }

                ctx.pos++;
            }

            lines.push({
                t: T_NUMBER,
                start: start,
                end: ctx.pos,
                text: text.substring(start, ctx.pos)
            });
            return true;
        }

        // Parses a series of terms like <term> (<operator> <term>)*
        // the parsers for term and operator can be specified as functions
        function parseChain(text, ctx, lines, type, termParser, opParser) {
            let start = advanceWhileWhitespace(text, ctx.pos);
            if (start >= text.length) {
                return false;
            }

            const terms = [];
            const ops = [];

            if (!termParser(text, ctx, terms)) {
                return false;
            }

            while (opParser(text, ctx, ops)) {
                if (!termParser(text, ctx, terms)) {
                    // remove the last operator we parsed, we shouldn't have
                    const op = ops.pop();

                    // reset end
                    ctx.pos = terms[terms.length - 1].end;
                    break;
                }
            }

            if (terms.length === 1) {
                // unwraps a single term to be it's own thing.
                // the AST becomes unmanageably large if we don't unwrap nodes like this.
                // although performance might be better, it is mainly a debugging optimization
                lines.push(terms[0]);
            } else {
                lines.push({
                    t: type,
                    start: start,
                    end: ctx.pos,
                    text: text.substring(start, ctx.pos),
                    terms: terms,
                    ops: ops,
                    show: false,
                    lineNumber: 0
                });
            }

            return true;
        }

        function parseGroup(text, ctx, lines) {
            const start = advanceWhileWhitespace(text, ctx.pos);
            if (start >= text.length) {
                return false;
            }

            if (text[start] === "(") {
                ctx.pos = start + 1;
                if (parseExpressionTopLevel(text, ctx, lines)) {
                    ctx.pos = advanceWhileWhitespace(text, ctx.pos);
                    if (text[ctx.pos] === ")") {
                        lines[lines.length - 1].start = start;
                        lines[lines.length - 1].end++;
                        ctx.pos++;
                        return true;
                    }
                }
            }
            return false;
        }

        // also parses a tensor indexing op like x[1][1][1]
        function parseVariable(text, ctx, lines) {
            const start = ctx.pos;

            if (!parseIdentifier(text, ctx, lines)) return false;
            return true;
        }

        function parseUnaryOp(text, ctx, lines) {
            const start = advanceWhileWhitespace(text, ctx.pos);
            if (start >= text.length) {
                return false;
            }

            const op = [];
            const expr = [];

            ctx.pos = start;
            if (!parseOneOf(text, ctx, op, unaryOps, T_UNARY_OP)) {
                return false;
            }

            ctx.pos = advanceWhileWhitespace(text, ctx.pos);
            if (!parseExpressionTopLevel(text, ctx, expr)) {
                return false;
            }

            lines.push({
                t: T_UNARY_OP,
                start: start,
                end: ctx.pos,
                op: op[0],
                expr: expr[0]
            });
            return true;
        }

        function parseIdentifier(text, ctx, lines) {
            const start = advanceWhileWhitespace(text, ctx.pos);
            if (start >= text.length) {
                return false;
            }

            let pos = start;
            if (!isLetter(text[pos])) {
                return false;
            }
            pos++;

            while (pos < text.length && (isDigit(text[pos]) || isLetter(text[pos]))) {
                pos++;
            }

            ctx.pos = pos;

            const identText = text.substring(start, ctx.pos);
            if (reservedKeywords.includes(identText)) return false;

            lines.push({
                t: T_IDENT,
                start: start,
                end: ctx.pos,
                text: identText
            });

            return true;
        }

        // this function does not know the size of the terminator, so it will stop on the terminator.
        // this is unlike all other parsing functions, that stop one after the final character
        function parseDelimitedList(text, ctx, lines, exprParser, hasDelimiter, hasTerminator, mustTerminate=true) {
            const start = advanceWhileWhitespace(text, ctx.pos);
            if (start >= text.length) {
                return false;
            }

            if (hasTerminator(text, ctx.pos)) {
                return true;
            }

            ctx.pos = start;
            let terminated = false;
            while (exprParser(text, ctx, lines)) {
                ctx.pos = advanceWhileWhitespace(text, ctx.pos);
                if (hasDelimiter(text, ctx.pos)) {
                    //text[nextStartPos] === delimiter
                    ctx.pos += 1;
                    continue;
                }

                if (hasTerminator(text, ctx.pos)) {
                    // text[nextStartPos] === terminator
                    terminated = true;
                    break;
                }

                return false;
            }

            if (mustTerminate && !terminated) {
                // allow for things like [1,2,] (trailing comma)
                ctx.pos = advanceWhileWhitespace(text, ctx.pos);
                if (!hasTerminator(text, ctx.pos)) {
                    return false;
                }
            }

            return true;
        }

        function parseFunctionCall(text, ctx, lines) {
            const start = advanceWhileWhitespace(text, ctx.pos);
            if (start >= text.length) {
                return false;
            }

            const name = [];
            const args = [];

            ctx.pos = start;
            if (!parseIdentifier(text, ctx, name)) {
                return false;
            }

            if (text[ctx.pos] != "(") {
                return false;
            }
            ctx.pos++;

            const argsStartPos = advanceWhileWhitespace(text, ctx.pos);

            ctx.pos = argsStartPos;
            if (
                !parseDelimitedList(
                    text,
                    ctx,
                    args,
                    parseAssignment,
                    (t, pos) => hasText(t, pos, ","),
                    (t, pos) => hasText(t, pos, ")")
                )
            ) {
                return false;
            }

            ctx.pos += 1;

            lines.push({
                t: T_FUNCTION_CALL,
                start: start,
                end: ctx.pos,
                name: name[0],
                args: args
            });

            return true;
        }

        // it assumes the starting pos already has a digit. don't call it otherwise
        function parseIntInline(text, ctx) {
            const start = ctx.pos;
            while (ctx.pos < text.length && isDigit(text[ctx.pos])) {
                ctx.pos++;
            }

            return parseInt(text.substring(start, ctx.pos));
        }

        // surprisingly complicated
        function parseTensor(text, ctx, lines) {
            const start = advanceWhileWhitespace(text, ctx.pos);
            if (start >= text.length) {
                return false;
            }

            const shape = [];

            if (text[start] !== "[") {
                return false;
            }

            ctx.pos += 1;
            const rows = [];
            // probably more optimal to only be parsing tensors or numbers here.
            if (
                !parseDelimitedList(
                    text,
                    ctx,
                    rows,
                    parseExpressionTopLevel,
                    (t, pos) => hasText(t, pos, ","),
                    (t, pos) => hasText(t, pos, "]")
                )
            ) {
                return false;
            }
            ctx.pos += 1;

            // we need to figure out the shape, and evaluate the inline expressions later in the evaluation step
            lines.push({
                t: T_TENSOR,
                start: start,
                end: ctx.pos,
                rows: rows,
                evaluated: false
            });
            return true;
        }

        // parses a time like 4:20 into a number representing the number of minutes since the start of the day.
        // useful for common duration calculations that I would use a calculator for
        function parseHmTime(text, ctx, lines) {
            const start = advanceWhileWhitespace(text, ctx.pos);
            if (start >= text.length) {
                return false;
            }
            ctx.pos = start;

            let h = 0, m = 0;

            if (!isDigit(text[ctx.pos])) return false;

            h = parseIntInline(text, ctx);

            ctx.pos = advanceWhileWhitespace(text, ctx.pos);

            if (text[ctx.pos] !== ":") return false;
            ctx.pos++;

            if (!isDigit(text[ctx.pos])) return false;

            const mTemp = []
            if (!parseNumber(text, ctx, mTemp)) return false; 
            m = evaluateNumber(mTemp[0]).val;
            
            ctx.pos = advanceWhileWhitespace(text, ctx.pos);
            if (hasText(text, ctx.pos, "am") || hasText(text, ctx.pos, "AM")) {
                ctx.pos += 2;
            } else if (hasText(text, ctx.pos, "pm") || hasText(text, ctx.pos, "PM")) {
                if(h < 12) {
                    h += 12;
                }
                ctx.pos += 2;
            }

            lines.push({
                t: T_NUMBER,
                start: start,
                end: ctx.pos,
                text: (h * 60 + m).toString()
            });
            return true;
        }

        function parseList(text, ctx, lines) {
            const start = advanceWhileWhitespace(text, ctx.pos);
            if (start >= text.length) {
                return false;
            }

            const items = [];

            if (text[ctx.pos] !== "<") return false;
            ctx.pos += 1;

            if (!parseDelimitedList(
                text, ctx, items, parseExpressionTopLevel,
                (t, pos) => hasText(t, pos, ","),
                (t, pos) => hasText(t, pos, ">"),
            )) {
                return false;
            }
            ctx.pos += 1;

            lines.push({
                t: T_LIST,
                start: start,
                end: ctx.pos,
                items: items,
            });
            return true;
        }

        function parseString(text, ctx, lines) {
            const start = advanceWhileWhitespace(text, ctx.pos);
            if (start >= text.length) {
                return false;
            }

            if (text[ctx.pos] !== "\"") return false;
            ctx.pos++;

            while(
                ctx.pos < text.length &&
                (text[ctx.pos] !== "\"" || (
                    text[ctx.pos] === "\"" && text[ctx.pos-1] === "\\"
                ))
            ) {
                ctx.pos++;
            }

            if (text[ctx.pos] !== "\"") return false;
            ctx.pos++;

            lines.push({
                t: T_STRING,
                start: start,
                end: ctx.pos,
                text: text.substring(start + 1, ctx.pos - 1).replace(/\\"/g, "\"")
            });
            return true;
        }

        // note that the ordering matters
        function parseThing(text, ctx, lines) {
            const start = advanceWhileWhitespace(text, ctx.pos);
            if (start >= text.length) {
                return false;
            }

            ctx.pos = start;
            if (parseBlock(text, ctx, lines)) return true;

            ctx.pos = start;
            if (parseGroup(text, ctx, lines)) return true;

            ctx.pos = start;
            if (parseUnaryOp(text, ctx, lines)) return true;

            ctx.pos = start;
            if (parseFunctionCall(text, ctx, lines)) return true;

            // important that this is after parseFunctionCall and what have you, the function name will be confused for a variable otherwise
            ctx.pos = start;
            if (parseVariable(text, ctx, lines)) return true;

            // primitives

            ctx.pos = start;
            if (parseHmTime(text, ctx, lines)) return true;

            ctx.pos = start;
            if (parseNumber(text, ctx, lines)) return true;

            ctx.pos = start;
            if (parseTensor(text, ctx, lines)) return true;

            ctx.pos = start;
            if (parseString(text, ctx, lines)) return true;

            ctx.pos = start;
            if (parseList(text, ctx, lines)) return true;

            return false;
        }

        function parseExponent(text, ctx, lines) {
            return parseChain(text, ctx, lines, T_TERM, parseThing, parseOpExponent);
        }

        function parseTerm(text, ctx, lines) {
            return parseChain(text, ctx, lines, T_TERM, parseExponent, parseOpTerm);
        }

        function parseExpression(text, ctx, lines) {
            return parseChain(text, ctx, lines, T_EXPR, parseTerm, parseOpExpr);
        }

        function parseComparison(text, ctx, lines) {
            return parseChain(text, ctx, lines, T_COMPARISON, parseExpression, parseOpComparison);
        }

        function parseIndexation(text, ctx, indexes) {
            if (text[ctx.pos] !== "[") {
                return false;
            }

            while (hasText(text, ctx.pos, "[")) {
                ctx.pos = advanceWhileWhitespace(text, ctx.pos + 1);

                if (!parseExpressionTopLevel(text, ctx, indexes)) return false;

                ctx.pos = advanceWhileWhitespace(text, ctx.pos);
                if (!text[ctx.pos] === "]") {
                    return false;
                }
                ctx.pos = advanceWhileWhitespace(text, ctx.pos + 1);
            }

            return true;
        }

        // consider having a new T_BLOCK or something
        function parseBlock(text, ctx, lines) {
            const body = [];

            ctx.pos = advanceWhileWhitespace(text, ctx.pos);
            if (ctx.pos >= text.length) {
                return false;
            }

            if (!hasText(text, ctx.pos, "{")) return false;
            ctx.pos = advanceWhileWhitespace(text, ctx.pos + 1);

            if (!hasText(text, ctx.pos, "}")) {
                if (!parseExpressionList(text, ctx, body)) return false;
                ctx.pos = advanceWhileWhitespace(text, ctx.pos);
            }

            if (!hasText(text, ctx.pos, "}")) {
                return false;
            }
            
            ctx.pos += 1;
            lines.push({
                t: T_BLOCK,
                body: body
            })
            return true;
        }

        function parseForLoop(text, ctx, lines) {
            const start = advanceWhileWhitespace(text, ctx.pos);
            if (start >= text.length ) {
                return false;
            }

            if (!hasText(text, ctx.pos, "for")) return false;

            ctx.pos = advanceWhileWhitespace(text, ctx.pos+3);

            const initializers = [];
            const loopCondition = [];
            const iterators = [];
            const loopBody = [];

            // parse initializers
            if (!parseDelimitedList(
                text, ctx, initializers, parseAssignment, 
                (t, pos) => hasText(t, pos, ","),
                (t, pos) => hasText(t, pos, ";"),
                false
            )) {
                return false;
            }
            ctx.pos = advanceWhileWhitespace(text, ctx.pos+1);

            // parse loop condition expression
            if (!parseExpressionTopLevel(text, ctx, loopCondition)) return false;
            ctx.pos = advanceWhileWhitespace(text, ctx.pos);

            if (!hasText(text, ctx.pos, ";")) return false;
            ctx.pos = advanceWhileWhitespace(text, ctx.pos+1);

            // parse loop iterators (this will stop exactly on the brace and not go past it)
            if (!parseDelimitedList(
                text, ctx, iterators, parseAssignment, 
                (t, pos) => hasText(t, pos, ","),
                (t, pos) => hasText(t, pos, "{")
            )) {
                return false;
            }

            // parse loop body
            if (!parseBlock(text, ctx, loopBody)){
                return false;
            }

            lines.push({
                t: T_FOR_LOOP,
                start: start,
                end: ctx.pos,
                initializers: initializers,
                loopCondition: loopCondition[0],
                iterators: iterators,
                loopBody: loopBody[0]
            });
            return true;
        }

        function parseExpressionTopLevel(text, ctx, lines) {
            const start = advanceWhileWhitespace(text, ctx.pos);
            if (start >= text.length ) {
                return false;
            }

            // TODO: try moving to root level as thing
            ctx.pos = start;
            if (parseForLoop(text, ctx, lines)) return true;

            // parse an expression. the ternary is the top-level of an expression.
            ctx.pos = start;
            if (!parseTernary(text, ctx, lines)) return false;

            const indexes = [];
            ctx.pos = advanceWhileWhitespace(text, ctx.pos);
            if (!parseIndexation(text, ctx, indexes)) return true;

            lines[lines.length - 1] = {
                t: T_EXPR_INDEXATION,
                start: start,
                end: ctx.pos,
                expr: lines[lines.length - 1],
                indexes: indexes
            };
            return true;
        }

        function parseTernary(text, ctx, lines) {
            const expr = [];
            if (!parseComparison(text, ctx, expr)) return false;

            const ternaryStart = advanceWhileWhitespace(text, ctx.pos);
            ctx.pos = ternaryStart;
            if (text[ctx.pos] !== "?") {
                // we only got an expression, that is fine
                lines.push(expr[0]);
                return true;
            }

            ctx.pos = advanceWhileWhitespace(text, ctx.pos + 1);

            if (!parseComparison(text, ctx, expr)) return false;

            ctx.pos = advanceWhileWhitespace(text, ctx.pos);
            if (text[ctx.pos] !== ":") {
                // we only got one branch of the ternary, that isn't enough
                return false;
            }

            // the next part can also be a ternary, i.e
            // x := y < 0 ? 2 : y > 3 ? 3 : 0

            ctx.pos = advanceWhileWhitespace(text, ctx.pos + 1);
            if (!parseTernary(text, ctx, expr)) {
                // we weren't able to parse the second branch of the ternary
                return false;
            }

            lines.push({
                t: T_TERNARY,
                start: ternaryStart,
                end: ctx.pos,
                conditional: expr[0],
                ifTrue: expr[1],
                else: expr[2]
            });
            return true;
        }

        // my compiler architecture prevents me from implementing += and -= properly at the moment, so 
        // I will hardcode them since they are so useful
        const ASSIGN_SET = "set";
        const ASSIGN_DECLARE = "declare";
        const ASSIGN_INCREMENT = "increment";
        const ASSIGN_DECREMENT = "decrement";

        function parseAssignment(text, ctx, lines) {
            const start = advanceWhileWhitespace(text, ctx.pos);
            if (start >= text.length) {
                return false;
            }

            const lhs = [];
            const rhs = [];
            if (!parseExpressionTopLevel(text, ctx, lhs)) return false;

            const assignOpPos = advanceWhileWhitespace(text, ctx.pos);

            let type = ASSIGN_SET;
            if (hasText(text, assignOpPos, "=")) {
                ctx.pos = assignOpPos + 1;
            } else if (hasText(text, assignOpPos, ":=")) {
                ctx.pos = assignOpPos + 2;
                type = ASSIGN_DECLARE;
            } else if (hasText(text, assignOpPos, "-=")) {
                ctx.pos = assignOpPos + 2;
                type = ASSIGN_DECREMENT;
            } else if (hasText(text, assignOpPos, "+=")) {
                ctx.pos = assignOpPos + 2;
                type = ASSIGN_INCREMENT;
            } else {
                // it isn't an assignment. we are just unwrapping
                lines.push(lhs[0]);
                return true;
            }

            if (!parseExpressionTopLevel(text, ctx, rhs)) {
                return false;
            } 

            lines.push({
                t: T_ASSIGNMENT,
                start: start,
                end: ctx.pos,
                lhs: lhs[0],
                rhs: rhs[0],
                assignType: type
            });
            return true;
        }

        function parseExpressionList(text, ctx, list) {
            const start = ctx.pos;

            while (parseAssignment(text, ctx, list)) {
                const endsWithSemicolon = text[ctx.pos] === ";";

                const lastAdded = list[list.length - 1];
                lastAdded.show = !endsWithSemicolon;
                lastAdded.lineNumber = text.substring(0, lastAdded.start).split("\n").length - 1;

                if (endsWithSemicolon) {
                    ctx.pos++;
                }
            }

            return start !== ctx.pos;
        }

        // return an AST-like thing
        function parseProgram(text) {
            const ctx = { pos: 0 };
            const lines = [];

            // this used to be a while loop, we may need to fix a bug here. if not, delete this comment
            parseExpressionList(text, ctx, lines);
            ctx.pos = advanceWhileWhitespace(text, ctx.pos);

            const root = {
                expressions: lines,

                // most error checking/validating is done in the evaluate step, so this has very limited use
                parseError: null
            };

            if (ctx.pos !== text.length) {
                const lines = text.substring(0, ctx.pos).split("\n");
                const linePos = ctx.pos - lines.lastIndexOf("\n");
                let contextText = text.substring(ctx.pos);
                if (contextText.length > 50) {
                    contextText = contextText.substring(0, 50) + "...";
                }
                root.parseError = `Couldn't read line ${lines.length} pos ${linePos}: "${contextText}"`;
            }

            return root;
        }

        function debugFormatAST(ast, text) {
            const dfs = (node) => {
                if (typeof node === "string") {
                    return;
                }

                if (node === null || node === undefined) {
                    return "undefined";
                }

                const limit = 10;
                if (
                    typeof node.length === "number" &&
                    node.length > limit &&
                    node.push !== undefined &&
                    node.splice !== undefined
                ) {
                    let originalLength = node.length;
                    node.splice(limit, node.length - limit);
                    node.push(
                        "and " +
                            (originalLength - limit) +
                            " more items that have been hidden for performance reasons"
                    );
                }

                for (const k of Object.keys(node)) {
                    dfs(node[k]);
                }
            };

            dfs(ast);
            return ast;
        }

        // ---- actual website code

        const input = document.getElementById("calculator-input");
        const showAstCheckbox = document.getElementById("show-ast-checkbox");
        const showResultCheckbox = document.getElementById("show-result-checkbox");
        const showAllTestcasesCheckbox = document.getElementById("show-all-tests");
        const showAstOutput = document.getElementById("ast-output");
        const showResultOutput = document.getElementById("result-output");
        const testcaseContainer = document.getElementById("testcases");
        const stdout = document.getElementById("stdout");

        // HTML doesn't like tabs, we need this additional code to be able to insert tabs.
        input.addEventListener("keydown", (e) => {
            if (e.keyCode !== 9) return;

            e.preventDefault();

            var start = input.selectionStart;
            var end = input.selectionEnd;

            // set textarea value to: text before caret + tab + text after caret
            input.value = input.value.substring(0, start) + "\t" + input.value.substring(end);

            // put caret at right position again
            input.selectionStart = input.selectionEnd = start + 1;

            onInputChange();
        });

        const onInputChange = () => {
            rerender();
        };

        input.addEventListener("input", onInputChange);

        showAstCheckbox.addEventListener("change", () => rerender());
        showResultCheckbox.addEventListener("change", () => rerender());
        showAllTestcasesCheckbox.addEventListener("change", () => rerenderTests());

        function rerender() {
            // line numbers.
            document.getElementById("line-numbers").innerText = [
                ...Array(input.value.split("\n").length).keys()
            ].join("\n");


            // may need debouncing in the future

            // debug outputs
            if (showAstCheckbox.checked) {
                showAstOutput.removeAttribute("hidden");
            } else {
                showAstOutput.setAttribute("hidden", true);
            }

            if (showResultCheckbox.checked) {
                showResultOutput.removeAttribute("hidden");
            } else {
                showResultOutput.setAttribute("hidden", true);
            }

            // parse and run code
            const text = input.value;
            const ast = parseProgram(text);
            const result = evaluateProgram(ast, text);

            // debugFormatAST damages the AST so wn have to run it after both parsing and evaluating the program
            showAstOutput.innerText = JSON.stringify(debugFormatAST(ast, text), null, 4);
            showResultOutput.innerText = JSON.stringify(result, null, 4);
            renderOutputs(result)
        }

        const hackySanitizationDiv = document.createElement("DIV");
        function sanitizeHTML(html) {
            return html
                .replace(/&/g, "&amp;")
                .replace(/</g, "&lt;")
                .replace(/>/g, "&gt;")
                .replace(/"/g, "&quot;")
                .replace(/'/g, "&#039;");
        }

        function renderOutputs(programCtx) {
            function p(innerHTML, className = "", el="p") {
                return `<${el} class="p-5 m-0 code ${className}">${sanitizeHTML(innerHTML)}</${el}>`;
            };

            function wrapInTitle(title, innerHtml) {
                return (
                    `<div class="flex-row">` + 
                        (title ? `<p class="p-5 m-0 label"><b>${title}: </b></p>` : "") + 
                        innerHtml +
                    "</div>"
                );
            }

            function print(stdout, result, i) {
                stdout.innerHTML += wrapInTitle(
                    result.title || `result ${i}`, 
                    p(thingToString(result.val), result.val.vt === VT_ERROR ? "error" : "")
                );
            }

            function plot(stdout, xValues, yValues) {
                // TODO: move code from function graph into here
            }

            function graph(stdout, result, i) {
                if (result.val && result.val.vt === VT_ERROR) {
                    return print(stdout, result, i);
                }

                const domainStart = result.start.val;
                const domainEnd = result.end.val;

                const paths = [], texts = [];

                const padding = 50;
                const w = 1000;
                const h = 500;
                const n = Math.floor(w);
                const points = Array(n * result.functions.length);
                
                

                // find graph bounds by evaluating functions
                let min = -20, max = -20;
                for(let fIndex = 0; fIndex < result.functions.length; fIndex++) {
                    const func = result.functions[fIndex];
                    programCtx.variables.pushStackFrame();
                    // set captures to values
                    for (let i = 0; i < func.captures.length; i++) {
                        programCtx.variables.set(programCtx, func.captures[i][0], func.captures[i][1], ASSIGN_DECLARE);
                    }

                    const fRef = makeNumber(0);
                    programCtx.variables.set(programCtx, func.args[0], fRef, ASSIGN_DECLARE);

                    for(let i = 0; i < n; i++) {
                        const tX = (i / (n - 1));

                        fRef.val = lerp(domainStart, domainEnd, tX);
                        
                        programCtx.variables.pushStackFrame();

                        const num = evaluateBlock(programCtx, func.body);

                        programCtx.variables.popStackFrame();

                        if (num.vt === VT_ERROR) {
                            print(stdout, { title: "An error occurred while graphing", val: num }, 0);
                            return;
                        }
                        const domainY = num.val;
                        
                        points[i + fIndex*n] = domainY;
                    }

                    programCtx.variables.popStackFrame();
                    
                    if (fIndex === 0) {
                        min = points[0];
                        max = points[0];
                    }

                    for(let i = 0; i < n; i++) {
                        min = points[i + fIndex*n] < min ? points[i + fIndex*n] : min;
                        max = points[i + fIndex*n] > max ? points[i + fIndex*n] : max;
                    }
                }

                const leftPad = 100, bottomPad = 17, topPad = 5;

                const axesOverhang = 10;
                // draw graph axes
                paths.push(
                    { p: `M ${leftPad - axesOverhang} ${h - bottomPad} L ${w} ${h - bottomPad}`, s: `black`, w: 1 },
                    { p: `M ${leftPad} ${h - bottomPad + axesOverhang} L ${leftPad} ${topPad}`, s: `black`, w: 1 },
                    { p: `M ${leftPad - axesOverhang} ${topPad} L ${w} ${topPad}`, s: `grey`, w: 1 },
                    { p: `M ${w} ${h - bottomPad + axesOverhang} L ${w} ${topPad}`, s: `grey`, w: 1 },
                );

                texts.push (
                    { t: `${min.toFixed(2)}`, x: leftPad - axesOverhang, y: h - bottomPad - axesOverhang, a: "end" },
                    { t: `${max.toFixed(2)}`, x: leftPad - axesOverhang, y: bottomPad + topPad, a: "end" },

                    { t: `${domainStart.toFixed(2)}`, x: leftPad + axesOverhang, y: h, a: "start" },
                    { t: `${domainEnd.toFixed(2)}`, x: w - axesOverhang, y: h, a: "end" },
                );

                // draw graph
                for(const fIndex in result.functions) {
                    const func = result.functions[fIndex];
                    const path = [];
                    for(let i = 0; i < n; i++) {
                        const tX = (i / (n - 1));
                        let x = leftPad + tX * (w - leftPad);
                        let y = topPad + (h - bottomPad - topPad) * (1 - (points[i + fIndex*n] - min) / (max - min));

                        if (i === 0) {
                            path.push("M" + x + " " + y);
                        } else {
                            path.push("L" + x + " " + y);
                        }
                    }

                    paths.push({ p: path.join(" ") , s: `hsl(${360 * fIndex / result.functions.length}, 100%, 50%)`, w: 2 });
                }

                stdout.innerHTML += wrapInTitle(
                    "graph of " + result.functions.map(f => f.name).join(", "),
                    `<svg id="graph-${i}" class="p-5 graph" style="width:${w}px;height:${h}px;">
                        ${paths.map(p => `<path d="${p.p}" stroke="${p.s}" stroke-width="${p.w}px" fill="none"></path>`).join("\n")}
                        ${texts.map(t => `<text text-anchor="${t.a}" x="${t.x}" y=${t.y} style="font-size:0.8em">${t.t}</text>`).join("\n")}
                        
                        <text class="mouseover mouse-pos-text" text-anchor="start" style="font-size:0.8em;"></text>
                        <path class="mouseover crosshair-path-1" stroke="grey" stroke-width="1"/>
                        <path class="mouseover crosshair-path-2" stroke="grey" stroke-width="1"/>
                        <rect x="${leftPad}" y="${topPad}" width="${w}" height="${h - bottomPad - topPad}" fill="transparent" class="graph-rect"></rect>
                    </svg>`
                ) + `<div class="code indent-3"><b>Bounds: </b>${domainStart} < x < ${domainEnd}\t | \t${min} < y < ${max}</div>`;

                setTimeout(() => {
                    const graph = document.getElementById("graph-" + i);
                    const mousePosText = graph.querySelector(".mouse-pos-text");
                    const graphRect = graph.querySelector(".graph-rect");
                    const crosshairPath1 = graph.querySelector(".crosshair-path-1");
                    const crosshairPath2 = graph.querySelector(".crosshair-path-2");

                    const mouseOverElements = graph.querySelectorAll(".mouseover");
                    graphRect.addEventListener("mousemove", (e) => {
                        const scrollAmnt = document.documentElement.scrollTop || document.body.scrollTop;
                        const rect = graphRect.getBoundingClientRect();
                        const rect2 = graph.getBoundingClientRect();

                        const tX = event.pageX - rect.left;
                        const tY = event.pageY - rect.top - scrollAmnt;

                        const domainX = lerp(domainStart, domainEnd, tX / (w - leftPad)).toFixed(3);
                        const domainY = lerp(max, min, tY / (h - bottomPad - topPad)).toFixed(3);

                        const viewX = event.pageX - rect2.left - 5;
                        const viewY = event.pageY - rect2.top - 5 - scrollAmnt;

                        mousePosText.innerHTML = domainX + ", " + domainY;
                        mousePosText.setAttribute("x", viewX + axesOverhang);
                        mousePosText.setAttribute("y", viewY - axesOverhang);
                        crosshairPath1.setAttribute("d", `M ${leftPad} ${viewY} L ${w} ${viewY}`)
                        crosshairPath2.setAttribute("d", `M ${viewX} ${topPad} L ${viewX} ${h - bottomPad}`)
                    });

                    graphRect.addEventListener("mouseenter", (e) => {
                        mouseOverElements.forEach(e => e.removeAttribute("hidden"));
                    });

                    graphRect.addEventListener("mouseleave", (e) => {
                        mouseOverElements.forEach(e => e.setAttribute("hidden", true));
                    });
                }, 5);
            }

            const outputs = [];
            stdout.innerHTML = "";

            if (programCtx.programResult.vt !== VT_NULL) {
                outputs.push(print(stdout, { title: "Calculation result", val: programCtx.programResult }));
            }

            // process and show all results, like print statements, graphs, etc.
            // we do it like this, so that we can still run unit tests without running side-effects
            if (programCtx.results.length > 0) {
                for(let i = 0; i < programCtx.results.length; i++) {
                    const result = programCtx.results[i];
                    if (result.rt === RT_PRINT) {
                        print(stdout, result, i);
                    } else if (result.rt === RT_PLOT) {
                        p("TODO");
                    } else if (result.rt === RT_GRAPH) {
                        graph(stdout, result, i);
                    } else {
                        p("unknown result type " + result.rt);
                    }

                    stdout.innerHTML += "\n";
                }
            }
        }

        // ---- add testcases,

        const testcases = [
            {
                name: "scope capturing",
                input: `
                funcs := <>;
for i := 0; i < 3; i+=1 {
	f(x) := sin(i*x)
	funcs += f;
}

g(x) := {
    // sometimes this sum variable can be mis-interpreted as a capture, in which case this won't work.
    // or we forget to push and pop a stack frame each time we evaluate this function in the graphing method, and
    // it thinks that sum is already declared
	sum := 0;
	for i := 0; i < len(funcs); i+= 1 {
		f := funcs[2];
		sum += f(x);
	}

	sum
}

// this must work
graph(g, 0, 1)
`,
                expected: "{}",
                isVisualTest: true
            },
            {
                name: "XSS attack",
                input: `"<p onclick='alert(\\"efaf\\")'>dasdas</p>"`,
                expected: `<p onclick='alert("efaf")'>dasdas</p>`,
            },
            {
                name: "typical math usecases",
                input: `
// most path expressions should be supported by this calculator
print(1 + 2 * 3 + 4^(sin(PI/2)*2), "first")

// do keep in mind that they are floating point numbers and not real numbers though
print(0.1+0.2, "0.1+0.2 (cries in floating point)")
`,
                expected: "{}",
                alwaysShow: true,
                isVisualTest: true
            },
            {
                name: "typical math expression",
                input: `1 + 2 * 3 + 4^(sin(PI/2)*2)`,
                expected: "23",
            },
            {
                name: "logical comparisons",
                input: `
// comparison operators will return 0 for false and 1 for true.
print(19 > 20, "comparison")

// Any number greater than 0.5 is considered true, and any number less than or equal to 0.5 is considered false
boolean(x) := x ? 1 : 0;
graph(boolean, 0, 1);
`,
                expected: "{}",
                alwaysShow: true,
                isVisualTest: true
            },
            {
                name: "graphing",
                input: `
// this feature is unpolished and in a very early stage (like most things here, but more-so).
// call the graph function with any number of functions, followed by a start and end value to graph it
graph(
	f(x) := sin(8 * x), 
	g(x) := cos(x), 
	0, 2*PI
)

// most of the javascript Math.whatever functions should be supported.
// although do keep in mind that some functions are not deterministic.
// the following function is different each time it is graphed
i := 0
random_boi(x) := { i += 0.1 * random(x)^6; i }
graph(
	random_boi,
	random_boi, 
	0, 10
)

// to add to the mystery, i is still zero: 
print(i)
`,
                expected: "{}",
                alwaysShow: true,
                isVisualTest: true
            },
            {
                name: "matrix multiplication",
                input:`
A := I(4);

v := [1,2,3,4]

A ** v`,
                expected: "shape: 1x4, data: [[1,  2,  3,  4]]",
            },
            {
                name: "matrix transpose",
                input: `
A:= [[1,  2,  3], 
	 [1,  2,  3], 
	 [2,  4,  6]]
~A
`,

                expected: `shape: 3x3, data: 	[[1,  1,  2], 	 [2,  2,  4], 	 [3,  3,  6]]`,
            },
            {
                name: "programming constructs - variable assignment",
                input: `
// the := operator makes a new variable:
x := 1

// the = operator assigns to an existing variable:
x = 2

// this distinction makes more sense when we have multiple scopes. 
i := -42
for i := 0; i < 3; i=i+1 {
    // the i here is different from the i out there
}

// (it should still be -42)
i
`,
                expected: "-42",
                alwaysShow: true,
            },
            {
                name: "programming constructs - blocks",
                input: `
// blocks are a list of expressions within curly braces {}.
// entire blocks are treated as expressions that are equal to the last line of the block
x := 2 * {
	y := 0;
    for i := 0; i < 10; i = i+1 {
        y += 1
    }
    y   // this here would be the last line of the block
};

x

`,  
                expected: "20",
                alwaysShow: true,
            },
            {
                name: "programming constructs - functions",
                input: `
// functions are defined as follows:

f(x) := x^2

// functions can call other functions or even themselves.
// functions can accept anything as arguments, including other functions.

g(y, func) := 2 * func(y)

g(2, f)
`,
                expected: "8",
                alwaysShow: true
            },
            {
                name: "function test",
                input: "fib(x) := x <= 1 ? 1 : fib(x - 1) + fib(x-2)\n\nfib(10)",
                expected: "89",
                alwaysShow: true
            },
            {
                name: "identity matrix for loop",
                input: "x := T(10, 10);\nfor i:=0; i < 10; i = i+1 {\n\tx[i][i]=1\n}\n\nx", 
                expected: "shape: 10x10, data:[[1, 0, 0, 0, 0, 0, 0, 0, 0, 0],[0, 1, 0, 0, 0, 0, 0, 0, 0, 0],[0, 0, 1, 0, 0, 0, 0, 0, 0, 0],[0, 0, 0, 1, 0, 0, 0, 0, 0, 0],[0, 0, 0, 0, 1, 0, 0, 0, 0, 0],[0, 0, 0, 0, 0, 1, 0, 0, 0, 0],[0, 0, 0, 0, 0, 0, 1, 0, 0, 0],[0, 0, 0, 0, 0, 0, 0, 1, 0, 0],[0, 0, 0, 0, 0, 0, 0, 0, 1, 0],[0, 0, 0, 0, 0, 0, 0, 0, 0, 1]]"
            },
            {
                name: "for loop local scope",
                input:"x := 0;\nfor i := 0; i < 5; i=i+1 { x = x + 1; }\nfor i := 0; i < 5; i=i+1 { x = x + 1; }\nx", 
                expected: "10"
            },
            {
                name: "for loop",
                input:"x := 0;\nfor i := 0; i < 5; i=i+1 { x = x + 1; }\nx", 
                expected: "5"
            },
            {
                name: "basic indexing",
                input: "x := [[1,2,3], [4,5,6]]; x[1][0]",
                expected: "4"
            },
            {
                name: "identity matrix",
                input: "x := T(3,3); x[[[0,0],[1,1],[2,2]]] = [1,1,1]; x",
                expected: `	shape: 3x3, data: [[1, 0, 0], [0, 1, 0], [0, 0, 1]]`
            },
            {
                name: "test assigning to index",
                input: "x := [1,2,3]; x[0]=2; x\nx = T(2,3); x[0] = [1,2,3]; x",
                expected: `	shape: 2x3, data: [[1, 2, 3], [0, 0, 0]]`
            },
            {
                name: "indexing test 2",
                input: "[[1,2,3],[4,5,6]][0]",
                expected: "	shape: 3, data: [1, 2, 3]"
            },
            {
                name: "indexing with fewer dimensions should return tensor",
                input: "[[[1,2,3],[4,5,6]], [[4,4,4],[4,5,6]]][[0, 1]]",
                expected: "	shape: 2x3, data: [[1, 2, 3], [4, 5, 6]]"
            },
            {
                name: "order of operations",
                input: `1 * 2 + 3 * 2^2`,
                expected: "14"
            },
            {
                name: "brackets",
                input: `2^(1+1) + (2 * 3)`,
                expected: "10"
            },
            {
                name: "variables",
                input: `x := 3;
y := 33 * x;
x = y * x + x`,
                expected: "300"
            },
            {
                name: "assignment error",
                input: `y := 3; y := 3`,
                expected: "variable y already defined, with value: 3"
            },
            {
                name: "builtin math functions",
                input: "sin(PI) + cos(PI)",
                expected: "-0.9999999999999999"
            },
            {
                name: "Function wrong input type error",
                input: "sin(x)",
                expected: "the variable x hasn't been declared yet. You can do something like x := 2; to declare it."
            },
            {
                name: "line comments",
                input: "x := // 324234 * sin(x)\n3; x",
                expected: "3"
            },
            {
                name: "ternary",
                input: "0 ? 100 : 2^2",
                expected: "4"
            },
            {
                name: "inline tensor",
                input: "[[1, 2, 3], [1, 2, 3]]",
                expected: "shape: 2x3, data: [[1, 2, 3], [1, 2, 3]] "
            },
            {
                name: "tensor func",
                input: "T(10, 10)",
                expected: "	shape: 10x10, data: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]"
            }
        ];

        function truncate(t, len) {
            if (t.length > len) {
                return t.substring(0, len) + "...";
            }

            return t;
        }

        function lerp(a, b, t) {
            t = t < 0 ? 0 : t;
            t = t > 1 ? 1 : t;

            return a + (b - a) * t;
        }

        function rerenderTests() {
            const onlyShowInteresting = !showAllTestcasesCheckbox.checked;
            let passes = 0, fails = 0, manual = 0;

            let tests = testcases
                    .filter((testcase) => onlyShowInteresting ? testcase.alwaysShow : true);

            let testcaseTableHTML =
            `
                <tr><th>Input</th><th>Output</th></tr>
            ` +
                tests.map((testcase, i) => {
                    let output = "", isPassing = false;

                    try {
                        const text = testcase.input;
                        const ast = parseProgram(text);
                        const results = evaluateProgram(ast, text);
                        output = valueToString(results.programResult);
                        isPassing = testcase.expected.replace(/\s/g, "") === output.replace(/\s/g, "");
                    } catch(e) {
                        output = "Exception";
                        isPassing = false;
                    }

                    if (!testcase.isVisualTest) {
                        if(isPassing){
                            passes++;
                        } else {
                            fails++;
                        }
                    } else {
                        manual++;
                    }

                    return `
                        <tr>
                            <td class="testcase-button" data-testcase-id="${i}">
                                <h4>${sanitizeHTML(testcase.name)}</h4>
                                <p class="code" title="click to put this code into the calculator">
                                    ${sanitizeHTML(testcase.input)}
                                </p>
                            </td>
                            <td class="${testcase.isVisualTest ? "" : isPassing ? "passing" : "failing"}" title="${testcase.isVisualTest ? "this test must be manually inspected" : isPassing ? "this testcase is passing" : "this testcase is failing"}">
                                ${
                                    isPassing ? truncate(sanitizeHTML(output), 70) : `
                                        <h4>Got:</h4>
                                        <p>
                                            ${sanitizeHTML(output)}
                                        </p>
                                        <h4>Expected:</h4>
                                        <p>
                                            ${sanitizeHTML(testcase.expected)}
                                        </p>
                                    `
                                }
                            </td>
                        </tr>`;
                    })
                    .join("\n");

            if(!onlyShowInteresting) {
                testcaseTableHTML = `
                    <p>
                        Passing: ${passes}, Failing: ${fails}, Requiring manual inspection: ${manual};
                    </p>
                ` 
                    + testcaseTableHTML;
            }

            testcaseContainer.innerHTML = testcaseTableHTML;
            for (let id = 0; id < tests.length; id++) {
                const button = testcaseContainer.querySelector(`.testcase-button[data-testcase-id="${id}"]`);
                button.addEventListener("click", (e) => {
                    window.scrollTo(0, 0);
                    input.value = tests[parseInt(button.getAttribute("data-testcase-id"))].input.trim();
                    rerender();
                });
            }
        }

        // ---- set value
        input.value = `1 + 1`;

`
funcs := <>;
for i := 0; i < 3; i+=1 {
	f(x) := sin(i*x)
	funcs += f;
}

graph(funcs, 0, 3)
`;
        rerender();
        rerenderTests();


        // ---- zen mode

        const zenMode = document.getElementById("zen-mode");
        zenMode.addEventListener("click", () => {
            document.querySelectorAll(".not-zen").forEach((el) => {
                el.setAttribute("hidden", true);
            });
        });

        document.addEventListener("keydown", (e) => {
            if (e.key === "Escape") {
                document.querySelectorAll(".not-zen").forEach((el) => {
                    el.removeAttribute("hidden", true);
                });
            }
        });

        // ---- end
    </script>
</html>
