<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Calculator</title>
    </head>
    <!-- // ---- styles -->
    <style>
        .testcase-button:hover {
            background: rgba(0,0,0,0.3);
            cursor: pointer;
        }

        .failing {
            background: rgba(255,0,0,0.5);
        }

        .passing {
            background: rgba(0,255,0,0.5);
        }

        *[hidden] {
            display: none !important;
        }

        body :focus {
            outline: none;
        }

        textarea {
            border: none;
            overflow: hidden;
            outline: none;

            margin: 0px;

            -webkit-box-shadow: none;
            -moz-box-shadow: none;
            box-shadow: none;

            resize: none; /*remove the resize handle on the bottom right*/
        }

        #input {
            padding-left: 5px;
            background: #000000;
            color: #ffffff;
            font-size: 1.2rem;
            line-height: 1.2rem;
            -moz-tab-size: 4;
            tab-size: 4;
        }
        #line-numbers {
            font-size: 1.2rem;
            line-height: 1.2rem;
            color: #aaaaaa;
            background: #000000;
            outline: none;
            border-right: 1px solid #aaaaaa;
        }

        .code div:before {
            content: "|";
            width: 20px;
        }

        .error {
            color: #ff0000;
        }

        th,
        td {
            outline: black solid 1px;
        }

        #testcases button {
            margin: 5px;
            display: block;
        }

        pre {
            margin: 0px;
        }

        #output {
            padding: 5px; 
            white-space: pre;
            tab-size: 4;
        }

        #input {
            
        }
    </style>
    <body style="font-family: 'Source Code Pro', monospace; margin: 0px">
        <div style="padding: 10px" class="not-zen">
            <h2>Calculator</h2>

            <div style="margin-top: 20px">
                <!-- Not intended to be an actual calculator. It is practice for creating a parser to making a
                programming language that I have been thinking about for a while now. This won't be the actual language, nor
                will it be complete, but I will try to add some cool features. I don't intend to spend any
                more than around 4 days on this site. (actually I ended up spending 2-3 weeks on it) -->
                <p>
                    Type something into the box below. Or, click on one of the examples in the table below.
                </p>
            </div>
        </div>
        <div>
            <!-- <div style="display: flex; flex-direction: row;">
                <div id="output" style="padding: 5px; white-space: pre; flex: 1; text-align:right;"></div>
                <div id="input" contenteditable="plaintext-only" style="padding: 5px; white-space: pre; min-height: 60px; flex: 1;"></div>
            </div> -->
            <div style="display: flex; flex-direction: row">
                <div id="line-numbers" style="padding: 5px; white-space: pre"></div>
                <textarea
                    id="input"
                    contenteditable="plaintext-only"
                    style="padding: 5px; white-space: pre; min-height: 60px; flex: 1"
                ></textarea>
            </div>
            <div id="output"></div>

            <div class="not-zen" style="margin-top: 50px; padding: 10px">
                <button id="zen-mode" style="width: unset">Remove clutter</button>
            </div>
        </div>
        <div style="padding: 10px" class="not-zen">
            <h3 title="these are really test cases">Debugging</h3>
            <input type="checkbox" id="show-ast-checkbox" />
            <label for="show-ast-checkbox">Show AST object</label><br />
            <pre id="ast-output" style="padding: 5px"></pre>
            <input type="checkbox" id="show-result-checkbox" />
            <label for="show-result-checkbox">Show result object</label><br />
            <input type="checkbox" id="show-all-tests" />
            <label for="show-all-tests">Show every testcase</label><br />

            <pre id="result-output" style="padding: 5px"></pre>
        </div>
        <div style="padding: 10px" class="not-zen">
            <div style="margin-top: 20px">
                <h3 title="these are really test cases">Examples</h3>
                <table id="testcases" style="width: 100%"></table>
            </div>
        </div>
    </body>
    <script>
        const debug = true;
        // const debug = false;

        // ---- evaluating the AST
        // This is before the parsing code, because the parser depends on some of the structures and stuff defined here.

        const VT_NUMBER = debug ? "VT_NUMBER" : 0;
        const VT_TENSOR = debug ? "VT_TENSOR" : 1;
        const VT_ERROR = debug ? "VT_ERROR" : 2;
        const VT_NULL = debug ? "VT_NULL" : 3;
        const VT_FUNCTION = debug ? "VT_FUNCTION" : 4;
        const VT_STRING = debug ? "VT_STRING" : 5;

        function makeErr(ctx, info) {
            const err = {
                vt: VT_ERROR,
                val: info
            };
            
            ctx.errors[0] = err;

            return err;
        }

        function vtToString(vt) {
            switch (vt) {
                case VT_NUMBER: return "NUMBER";
                case VT_TENSOR: return "TENSOR";
                case VT_ERROR: return "ERROR";
                case VT_NULL: return "NULL";
                case VT_FUNCTION: return "FUNCTION";
                case VT_STRING: return "STRING";
            }
            return "unknown type " + vt;
        }

        function evaluateNumber(x) {
            return makeNumber(parseFloat(x.text));
        }

        function makeNumber(n) {
            return { vt: VT_NUMBER, val: n};
        }

        function makeString(s) {
            return { vt: VT_STRING, val: s };
        }

        const builtInConstantsMap = {
            PI: makeNumber(Math.PI.toString()),
            E: makeNumber(Math.E.toString()),
            // golden ratio
            PHI: makeNumber("1.618033988749")
        };
        const builtInConstants = Object.keys(builtInConstantsMap);

        function hasVariable(ctx, name) {
            if(reservedKeywords.includes(name)) return true;
            if (builtInConstants.includes(name)) return true;
            if (ctx.variables.has(name)) return true;

            return false;
        }

        function getVariable(ctx, name, shouldReturnError = true) {
            if (typeof name !== "string") {
                throw new Error("You aren't calling getVariable right");
            }

            let v = builtInConstantsMap[name];
            if (v) {
                return v;
            }
            v = ctx.variables.get(name);
            if (v) {
                return v;
            }

            if (shouldReturnError) {
                return makeErr(
                    ctx,
                    `the variable ${name} hasn't been declared yet.
    You can do something like ${name} := 2; to declare it. (the semicolon supresses output)`
                );
            }

            return null;
        }

        function evaluateVariable(ctx, x, err = true) {
            const name = x.text;
            return getVariable(ctx, name, err)
        }

        function copyTensor(a) {
            return {
                vt: VT_TENSOR,
                shape: a.shape.slice(),
                data: a.data.slice()
            };
        }

        function getMatrixStride(ctx, a, b) {
            let remainderPart = a.shape.length - b.shape.length;
            if (a.shape.length === 1 && b.shape.length === 1 && b.shape[0] === 1) {
                return 1;
            } else if(areSameShape(a.shape.slice(remainderPart), b.shape)) {
                return a.shape.slice(remainderPart).reduce((a, b) => a * b, 1);
            } else {
                return makeErr(ctx, "wrong sizes");
            }
        }

        function performElementwiseOp(ctx, a, b, op) {
            const stride = getMatrixStride(ctx, a, b);
            if (stride.vt === VT_ERROR) return stride;

            const newTensor = copyTensor(a);

            for(let i = 0; i < a.data.length; i += stride) {
                for(let j = 0; j < b.data.length; j++) {
                    newTensor.data[i + j] = op(newTensor.data[i + j], b.data[j]);
                }
            }

            return newTensor;
        }

        // the function operator(T1, t2) can be found by doing binOpMatrix[t1][t2][operator].
        const binOpMatrix = {
            [VT_NUMBER]: {
                [VT_NUMBER]: {
                    "+": (ctx, a, b) => makeNumber(a.val + b.val),
                    "<": (ctx, a, b) => makeNumber(a.val < b.val ? 1.0 : 0.0),
                    ">": (ctx, a, b) => makeNumber(a.val > b.val ? 1.0 : 0.0),
                    "<=": (ctx, a, b) => makeNumber(a.val <= b.val ? 1.0 : 0.0),
                    ">=": (ctx, a, b) => makeNumber(a.val >= b.val ? 1.0 : 0.0),
                    "==": (ctx, a, b) => makeNumber(Math.abs(a.val - b.val) < 0.0000000001 ? 1.0 : 0.0),
                    "-": (ctx, a, b) => makeNumber(a.val - b.val),
                    "*": (ctx, a, b) => makeNumber(a.val * b.val),
                    "/": (ctx, a, b) => makeNumber(a.val / b.val),
                    "%": (ctx, a, b) => makeNumber(a.val % b.val),
                    "^": (ctx, a, b) => makeNumber(Math.pow(a.val, b.val)),
                }
            },
            [VT_TENSOR]: {
                [VT_TENSOR]: {
                    "**": (ctx, a, b) => {
                        if (a.shape.length === 1 && b.shape.length === 1 && a.shape[0] === b.shape[0]) {
                            let sum = 0;
                            for(let i = 0; i < a.data.length; i++) {
                                sum += a.data[i] * b.data[i];
                            }
                            return makeNumber(sum);
                        }

                        // matrix multiplication
                        let aW = a.shape.length === 1 ? a.shape[0] : a.shape[1];
                        let bW = b.shape.length === 0 ? 1 : (b.shape[1] || 1);
                        let aH = a.shape.length === 1 ? 1 : a.shape[0];
                        let bH = b.shape.length === 1 ? b.shape[0] : b.shape[0];

                        if (a.shape.length > 2 || b.shape.length > 2) {
                            return makeErr(ctx, `matrix multiplication only works with matrices/vectors for now`);
                        }
                        if (aW !== bH) {
                            return makeErr(ctx, `second matrix row count (${bH}) must equal first matrix column count ${aW}`);
                        }

                        const newData = Array(bW * aH);

                        for(let i = 0; i < bW; i++) {
                            for(let j = 0; j < aH; j++) {
                                let dotP = 0;
                                for(let k = 0; k < bH; k++) {
                                    dotP += a.data[k + j*aW] *
                                        b.data[i + k*bW];
                                }
                                newData[i + j*bW] = dotP;
                            }
                        }

                        return {
                            vt: VT_TENSOR,
                            data: newData,
                            shape: [bW, aH]
                        };
                    },

                    "<": (ctx, a, b) => performElementwiseOp(ctx, a, b, (a, b) => a < b ? 1.0 : 0.0),
                    ">": (ctx, a, b) => performElementwiseOp(ctx, a, b, (a, b) => a > b ? 1.0 : 0.0),
                    "<=": (ctx, a, b) => performElementwiseOp(ctx, a, b, (a, b) => a <= b ? 1.0 : 0.0),
                    ">=": (ctx, a, b) => performElementwiseOp(ctx, a, b, (a, b) => a >= b ? 1.0 : 0.0),
                    "==": (ctx, a, b) => performElementwiseOp(ctx, a, b, (a, b) => Math.abs(a - b) > 0.0000000001 ? 1.0 : 0.0),
                    "+": (ctx, a, b) => performElementwiseOp(ctx, a, b, (a, b) => a + b),
                    "-": (ctx, a, b) => performElementwiseOp(ctx, a, b, (a, b) => a - b),
                    "*": (ctx, a, b) => performElementwiseOp(ctx, a, b, (a, b) => a * b),
                    "/": (ctx, a, b) => performElementwiseOp(ctx, a, b, (a, b) => a / b),
                    "%": (ctx, a, b) => performElementwiseOp(ctx, a, b, (a, b) => a % b),
                    "^": (ctx, a, b) => performElementwiseOp(ctx, a, b, (a, b) => Math.pow(a, b)),
                }
            },
            [VT_STRING]: {
                [VT_STRING]: {
                    "+": (ctx, a, b) => ({ vt: a.vt, val: a.val + b.val }),
                }
            }
        };

        function applyOperator(ctx, lhs, rhs, op) {
            const t1 = lhs.vt;
            const t2 = rhs.vt;

            let binOp = null,
                binOpL1 = null,
                binOpL2 = null;
            binOpL1 = binOpMatrix[t1];
            if (binOpL1) {
                binOpL2 = binOpL1[t2];
                if (binOpL2) {
                    binOp = binOpL2[op.text];
                }
            }

            if (!binOp) {
                // find the largest common shape, and try to multiply component-wise
                if (t1.vt === VT_TENSOR) {
                }

                return makeErr(
                    ctx,
                    `the operation ${vtToString(t1)} ${op.text} ${vtToString(t2)} doesn't exist yet`
                );
            }

            return binOp(ctx, lhs, rhs);
        }

        function evaluateChain(ctx, x) {
            let val = evaluateExpression(ctx, x.terms[0]);
            for (let i = 1; i < x.terms.length; i++) {
                const val2 = evaluateExpression(ctx, x.terms[i]);
                val = applyOperator(ctx, val, val2, x.ops[i - 1]);
            }
            return val;
        }

        const unaryOpsMap = {
            [VT_NUMBER]: {
                "+": (x) => x,
                "-": (x) => ({ vt: x.vt, val: -x.val }),
            },
            [VT_TENSOR]: {
                "-": (x) => {
                    const tensor = copyTensor(x);
                    for(let i = 0; i < tensor.data.length; i++) {
                        tensor.data[i] = -tensor.data[i];
                    }
                    return tensor;
                },
                "~": (x) => {
                    if (x.shape.length > 2) {
                        // I don't have the math knowledge required to make this work for tensors,
                        // nor do I have a use case beyond matrices, so I shouldn't waste my time on getting this to work
                        return makeErr(ctx, `transposing is only defined on matrices and vectors at the moment`);
                    }

                    const tensor = copyTensor(x);

                    if (x.shape.length === 1) {
                        tensor.shape = [1, tensor.shape];
                        return tensor;
                    } 

                    // Even though you may be used to seeing width followed by height everywhere, w, h is the correct reverse order here. 
                    let w = x.shape[1];
                    let h = x.shape[0];
                    tensor.shape = [w, h];
                    for(let i = 0; i < w; i++) {
                        for(let j = 0; j < h; j++) {
                            tensor.data[i*h + j] = x.data[i + j*w]
                        }
                    }

                    return tensor;
                }
            }
        };
        const unaryOps = [];
        for (const typeKey in unaryOpsMap) {
            const opList = unaryOpsMap[typeKey];
            for (const op in opList) {
                unaryOps.push(op);
            }
        }

        function evaluateUnaryOp(ctx, x) {
            const val = evaluateExpression(ctx, x.expr);
            const func = unaryOpsMap[val.vt][x.op.text];
            if (!func) {
                return makeErr(ctx, `unary op ${x.op.text} can't be used on ${vtToString(val.vt)}`);
            }

            return func(val);
        }

        function getVals(args) {
            return args.map(v => v.val)
        }

        // imagine building an interpreted language in an interpreted language
        // also we need a way to represent infinite args. our tensor function can actually take in infinite number args
        const builtinFunctionsMap = {
            abs: {
                args: [{ vt: VT_NUMBER }],
                fn: (ctx, ...args) => makeNumber(Math.abs(getVals(args)))
            },
            acos: {
                args: [{ vt: VT_NUMBER }],
                fn: (ctx, ...args) => makeNumber(Math.acos(getVals(args)))
            },
            acosh: {
                args: [{ vt: VT_NUMBER }],
                fn: (ctx, ...args) => makeNumber(Math.acosh(getVals(args)))
            },
            asin: {
                args: [{ vt: VT_NUMBER }],
                fn: (ctx, ...args) => makeNumber(Math.asin(getVals(args)))
            },
            asinh: {
                args: [{ vt: VT_NUMBER }],
                fn: (ctx, ...args) => makeNumber(Math.asinh(getVals(args)))
            },
            atan: {
                args: [{ vt: VT_NUMBER }],
                fn: (ctx, ...args) => makeNumber(Math.atan(getVals(args)))
            },
            atanh: {
                args: [{ vt: VT_NUMBER }],
                fn: (ctx, ...args) => makeNumber(Math.atanh(getVals(args)))
            },
            atan2: {
                args: [{ vt: VT_NUMBER }, { vt: VT_NUMBER }],
                fn: (ctx, ...args) => makeNumber(Math.atan2(getVals(args)))
            },
            ceil: {
                args: [{ vt: VT_NUMBER }],
                fn: (ctx, ...args) => makeNumber(Math.ceil(getVals(args)))
            },
            cos: {
                args: [{ vt: VT_NUMBER }],
                fn: (ctx, ...args) => makeNumber(Math.cos(getVals(args)))
            },
            cosh: {
                args: [{ vt: VT_NUMBER }],
                fn: (ctx, ...args) => makeNumber(Math.cosh(getVals(args)))
            },
            exp: {
                args: [{ vt: VT_NUMBER }],
                fn: (ctx, ...args) => makeNumber(Math.exp(getVals(args)))
            },
            floor: {
                args: [{ vt: VT_NUMBER }],
                fn: (ctx, ...args) => makeNumber(Math.floor(getVals(args)))
            },
            hypot: {
                args: [{ vt: VT_NUMBER }],
                fn: (ctx, ...args) => makeNumber(Math.hypot(getVals(args)))
            },
            imul: {
                args: [{ vt: VT_NUMBER }],
                fn: (ctx, ...args) => makeNumber(Math.imul(getVals(args)))
            },
            log: {
                args: [{ vt: VT_NUMBER }],
                fn: (ctx, ...args) => makeNumber(Math.log(getVals(args)))
            },
            log1p: {
                args: [{ vt: VT_NUMBER }],
                fn: (ctx, ...args) => makeNumber(Math.log1p(getVals(args)))
            },
            log10: {
                args: [{ vt: VT_NUMBER }],
                fn: (ctx, ...args) => makeNumber(Math.log10(getVals(args)))
            },
            log2: {
                args: [{ vt: VT_NUMBER }],
                fn: (ctx, ...args) => makeNumber(Math.log2(getVals(args)))
            },
            max: {
                args: [{ vt: VT_NUMBER }],
                fn: (ctx, ...args) => makeNumber(Math.max(getVals(args)))
            },
            min: {
                args: [{ vt: VT_NUMBER }],
                fn: (ctx, ...args) => makeNumber(Math.min(getVals(args)))
            },
            pow: {
                args: [{ vt: VT_NUMBER }, { vt: VT_NUMBER }],
                fn: (ctx, ...args) => makeNumber(Math.pow(getVals(args)))
            },
            random: {
                args: [{ vt: VT_NUMBER }],
                fn: (ctx, ...args) => makeNumber(Math.random(getVals(args)))
            },
            round: {
                args: [{ vt: VT_NUMBER }],
                fn: (ctx, ...args) => makeNumber(Math.round(getVals(args)))
            },
            sign: {
                args: [{ vt: VT_NUMBER }],
                fn: (ctx, ...args) => makeNumber(Math.sign(getVals(args)))
            },
            sin: {
                args: [{ vt: VT_NUMBER }],
                fn: (ctx, ...args) => makeNumber(Math.sin(getVals(args)))
            },
            sinh: {
                args: [{ vt: VT_NUMBER }],
                fn: (ctx, ...args) => makeNumber(Math.sinh(getVals(args)))
            },
            sqrt: {
                args: [{ vt: VT_NUMBER }],
                fn: (ctx, ...args) => makeNumber(Math.sqrt(getVals(args)))
            },
            tan: {
                args: [{ vt: VT_NUMBER }],
                fn: (ctx, ...args) => makeNumber(Math.tan(getVals(args)))
            },
            tanh: {
                args: [{ vt: VT_NUMBER }],
                fn: (ctx, ...args) => makeNumber(Math.tanh(getVals(args)))
            },
            trunc: {
                args: [{ vt: VT_NUMBER }],
                fn: (ctx, ...args) => makeNumber(Math.trunc(getVals(args)))
            },

            // Non-wrapping builtins

            T: {
                args: [{ vt: VT_NUMBER }],
                fn: (ctx, ...args) => ({
                    vt: VT_TENSOR,
                    data: Array(args.map((x) => x.val).reduce((prev, next) => prev * next, 1)).fill(0),
                    shape: args.map((x) => x.val)
                }) // no error checks? TODO: add. later, of
            },
            I: {
                args: [{ vt: VT_NUMBER }],
                fn: (ctx, size) => {
                    const tensor = builtinFunctionsMap.T.fn(ctx, size, size);
                    for(let i = 0; i < size.val; i++) {
                        tensor.data[i + size.val * i] = 1;
                    }
                    return tensor;
                }
            },

            // prints a number of minutes as hours and minutes. 
            toHm: {
                args: [{ vt: VT_NUMBER}],
                fn: (ctx, v) => makeString(`${Math.floor(v.val / 60)}h ${v.val % 60}m`)
            },
            dot: {
                args: [{vt: VT_TENSOR}, {vt: VT_TENSOR}],
                fn: (ctx, a, b) => {
                    if (!areSameShape(a.shape, b.shape)) {
                        return makeErr(ctx, `two tensors must have the same shape for a dot product`)
                    }

                    let sum = 0;
                    for(let i = 0; i < a.data.length; i++) {
                        sum += a.data[i] + b.data[i];
                    }
                    return makeNumber(sum);
                }
            }
        };
        const builtinFunctions = Object.keys(builtinFunctionsMap);

        function evaluateUserDefFunctionCall(ctx, x, name) {
            const func = ctx.variables.get(name);
            if (!func) {
                return makeErr(ctx, `function '${name}' not found`);
            }
            if (func.vt !== VT_FUNCTION) {
                return makeErr(ctx, `'${name}' is not a function that can be called`);
            }

            if (x.args.length !== func.args.length) {
                return makeErr(ctx, `user defined function ${name} wants ${func.args.length} arguments, only ${x.args.length} were provided`);
            }

            ctx.variables.pushStackFrame();

            const argumentNames = func.args;
            const argumentValues = x.args;

            // set arguments to values
            for (let i = 0; i < argumentNames.length; i++) {
                ctx.variables.set(ctx, argumentNames[i], evaluateExpression(ctx, argumentValues[i]), true);
            }

            const val = evaluateBlock(ctx, func.body, func.args, x.args);;


            ctx.variables.popStackFrame();

            return val;
        }

        function evaluateFunctionCall(ctx, x) {
            const name = x.name.text;
            const func = builtinFunctionsMap[name];
            if (!func) {
                // user defined funciton
                return evaluateUserDefFunctionCall(ctx, x, name);
            }

            const argsEvaluated = x.args.map((arg) => evaluateExpression(ctx, arg));

            // I don't care if the argument counts don't match at the moment.
            // some of the javascript math functions might accept variadic ...args,
            // and it is more important that I am able to use that than it is that I get errors about argument counts
            // at the moment.

            for (let i = 0; i < func.args.length; i++) {
                if (argsEvaluated[i].vt !== func.args[i].vt) {
                    return makeErr(
                        ctx,
                        `Argument ${i} to function ${name} was of type ${vtToString(
                            argsEvaluated[i].vt
                        )}, but it wants ${vtToString(func.args[i].vt)}`
                    );
                }
            }

            return func.fn(ctx, ...argsEvaluated);
        }

        function evaluateFunctionAssignment(ctx, x, varName) {
            const fn = x.lhs;
            varName = fn.name.text;
            let argNames = Array(fn.args.length);
            for(let i = 0; i < fn.args.length; i++) {
                if (fn.args[i].t !== T_IDENT) {
                    return makeErr(`declaration of function ${varName} accepts an invalid variable: '${nodeText(ctx, fn.args[i])}' (hint: just use a simpler name, like 'x' or something)`);
                }

                argNames[i] = fn.args[i].text;
            }

            const body = x.rhs.t === T_BLOCK ? x.rhs : {
                t: T_BLOCK, 
                body: [x.rhs]
            };

            ctx.variables.set(ctx, varName, {
                vt: VT_FUNCTION,
                args: argNames,
                body: body,
                text: nodeText(ctx, x)
            }, x.isDeclaration);

            return null;
        }

        // TODO: split up function to variable assignment, indexation assignment and function assignment
        function evaluateAssignment(ctx, x) {
            let varName = null;
            let isIndexation = false;
            if (x.lhs.t === T_FUNCTION_CALL) {
                return evaluateFunctionAssignment(ctx, x);
            }

            if (x.lhs.t === T_IDENT) {
                varName = x.lhs.text;
            } else if (x.lhs.t === T_EXPR_INDEXATION && x.lhs.expr.t === T_IDENT) {
                varName = x.lhs.expr.text;
                isIndexation = true;
            } else {
                return makeErr(ctx, `can't assign to lhs type ${x.lhs.t}`);
            }

            // check if variable can be assigned to
            if (!varName) {
                return makeErr(ctx, `identifier was blank`);
            }
            if (builtinFunctions.includes(varName)) {
                return makeErr(
                    ctx,
                    Math.random() < 0.05
                        ? `NOO!!! you cant just redeclare functions !!!`
                        : `a builtin function already exists with this name`
                );
            }

            const rhs = evaluateExpression(ctx, x.rhs);
            const existingVar = getVariable(ctx, varName, false);

            if (isIndexation) {
                if (x.isDeclaration) {
                    return makeErr(ctx, `${ctx.text.substring(x.start, x.end)} - can't declare a new variable inside a thing, doesn't make sense conceptually (hint: just use '=')`);
                }
            }
            // isDeclaration will always be false when isIndexation is true from here on

            if (isIndexation) {
                if (x.isDeclaration) {
                    return makeErr(ctx, `can't declare a new variable inside a tensor, doesn't make sense conceptually (hint: just use '=')`);
                }

                // we are going to set the values directly in the tensor
                const tensor = existingVar;

                const [flattenedIndices, remainingShape, err] = evaluateIndicesToFlatArray(ctx, x, tensor.shape, x.lhs.indexes.map(x => evaluateExpression(ctx, x)));
                if (err !== null) {
                    return err;
                }

                // the thing we're assigning to should have the same shape (at some level at least)
                if (remainingShape.length === 0) {
                    if (rhs.vt === VT_TENSOR) {
                        if (flattenedIndices.length !== rhs.data.length) {
                            return makeErr(ctx, `rhs of ${nodeText(ctx, x)} needs the same number of elements as indices (${flattenedIndices.length}), instead ${rhs.data.length} were provided`)
                        }

                        for(let i = 0; i < flattenedIndices.length; i++) {
                            tensor.data[flattenedIndices[i]] = rhs.data[i];
                        }
                    } else if (rhs.vt === VT_NUMBER) {
                        for(let i = 0; i < flattenedIndices.length; i++) {
                            tensor.data[flattenedIndices[i]] = rhs.val;
                        }
                    } else {
                        return makeErr(ctx, `rhs must be a number or tensor`)
                    }
                } else {
                    if (rhs.vt !== VT_TENSOR) {
                        return makeErr(ctx, `rhs must be a tensor`);
                    }

                    if (!areSameShape(rhs.shape, remainingShape)) {
                        return makeErr(ctx, `rhs must be a tensor with shape ` + remainingShape.join("x"));
                    }

                    // we can do this, because rhs is the same shape as the remaining tensor
                    for(let i = 0; i < flattenedIndices.length; i++) {
                        for(let j = 0; j < rhs.data.length; j++) {
                            tensor.data[flattenedIndices[i] + j] = rhs.data[j];
                        }
                    }
                }

                return rhs;
            };


            let setError = ctx.variables.set(ctx, varName, rhs, x.isDeclaration);
            if (setError !== null) {
                return setError;
            }

            return rhs;
        }

        function isTrue(x) {
            return x.vt === VT_NUMBER && x.val >= 0.5;
        }

        function evaluateTernary(ctx, x) {
            const condition = evaluateExpression(ctx, x.conditional);
            if (condition.vt !== VT_NUMBER) {
                return makeErr(
                    ctx,
                    `condition needs to be a number, anything less than 0.5 is false, anything >= 0.5 is true`
                );
            }

            if (isTrue(condition)) {
                return evaluateExpression(ctx, x.ifTrue);
            }

            return evaluateExpression(ctx, x.else);
        }

        // takes in two shapes, not two tensors
        function areSameShape(s1, s2) {
            if (s1.length !== s2.length) return false;

            for (const i in s1) {
                if (s1[i] !== s2[i]) return false;
            }

            return true;
        }

        function nodeText(ctx, node) {
            return `${ctx.text.substring(node.start, node.end)}`;
        }

        function evaluateTensor(ctx, x) {
            const depthFirstEvalTensor = (x) => {
                if (x.t !== T_TENSOR) {
                    let val = evaluateExpression(ctx, x);
                    if (val.vt === VT_NUMBER || val.vt === VT_TENSOR) {
                        return val;
                    }

                    return makeErr(
                        ctx,
                        `bottom level item ${nodeText(ctx, x)} in tensor not of correct type - ${vtToString(val.vt)}`
                    );
                }

                const tensor = {
                    vt: VT_TENSOR,
                    data: [],
                    shape: []
                };

                let expectedShape = null;
                for (let i = 0; i < x.rows.length; i++) {
                    let row = depthFirstEvalTensor(x.rows[i]);
                    if (row.vt === VT_ERROR) {
                        return row;
                    }

                    if (row.vt === VT_TENSOR) {
                        if (expectedShape === null) {
                            expectedShape = row.shape;
                        } else if (!areSameShape(expectedShape, row.shape)) {
                            return makeErr(
                                ctx,
                                `one of the elements of the tensor was the wrong size: ${nodeText(ctx, x.rows[i])}`
                            );
                        }

                        tensor.data.push(...row.data);
                    } else if (row.vt === VT_NUMBER) {
                        expectedShape = [];
                        tensor.data.push(row.val);
                    }
                }

                tensor.shape = [x.rows.length, ...expectedShape];

                return tensor;
            };

            const tensor = depthFirstEvalTensor(x);

            return tensor;
        }

        function evaluateIndicesToFlatArray(ctx, errorNode, shape, indexes) {
            const strides = Array(shape.length);

            // at each level, we should know how big the stride is.
            // we calculate this with a cumulative sum. at the lowest level, the stride is 1.
            // if we have a 2x3 matrix, the things would be [6, 3, 1], with 6 being the total number of things in
            // the entire matrix and hence not very useful
            strides[strides.length - 1] = 1;
            for (let i = shape.length - 2; i >= 0; i--) {
                strides[i] = shape[i + 1] * strides[i + 1];
            }

            // now, we have some indices that need to become a list of indexes.
            // if we have [1,2,3][1], then 1 is the index.
            // if we have [1,2,3][[1, 2]], then we really want 2 indices - 1 and two.
            // [[1,2,3],[4,5,6]][1][0] -> 3 + 0
            // [[1,2,3],[4,5,6]][[0, 1]][0] -> [0 + 0, 3 + 0]
            const flatIndexes = [0];
            let i = 0;
            while(i < indexes.length) { // incrementing i is done on a type by type basis. it is basically the current 'dimension'
                const idx = indexes[i];
                if (idx.vt === VT_NUMBER) {
                    for (let j = 0; j < flatIndexes.length; j++) {
                        if (idx.val < 0 || idx.val >= shape[i]) {
                            return [null, null, makeErr(ctx, `index ${idx.val} in ${nodeText(ctx, errorNode)} was out of bounds`)];
                        }
                        
                        flatIndexes[j] += strides[i] * idx.val;
                    }
                    i++;
                } else if (idx.vt === VT_TENSOR) {
                    let isListOfVectors = idx.shape.length === 2;
                    let isListOfNumbers = idx.shape.length === 1;
                    if (!isListOfNumbers && !isListOfVectors) {
                        return [null, null, makeErr(ctx,`only numbers, lists of numbers, or lists of vectors can be used as indices. \n\t(Note that this doesn't include vectors, as they can be misconstrued as a list of numbers. You will need to wrap your vector in a list)`)];
                    }

                    // copy the indices we already have for each index specified
                    let originalLen = flatIndexes.length;
                    let numIndices = isListOfNumbers ? idx.data.length : idx.shape[0];
                    for (let j = 0; j < numIndices - 1; j++) {
                        flatIndexes.push(...flatIndexes.slice(0, originalLen));
                    }

                    if (isListOfNumbers) {
                        for (let j = 0; j < numIndices; j++) {
                            // bounds check
                            if (idx.data[j] < 0 || idx.data[j] >= shape[i]) {
                                return [null, null, makeErr(ctx, `index ${idx.data[j]} in ${nodeText(ctx, errorNode)} was out of bounds`)];
                            }
    
                            // TODO: better comment
                            // increment the index by the current dimension
                            for (let k = 0; k < originalLen; k++) {
                                flatIndexes[j * originalLen + k] += strides[i] * idx.data[j];
                            }
                        }
                        i++;
                    } else {
                        const vecSize = idx.shape[1];
                        if (i + vecSize > shape.length) {
                            return [null, null, makeErr(ctx, `the indexing part of ${nodeText(ctx, errorNode)} has too many dimensions`)];
                        }

                        for(let j = 0; j < numIndices; j++) {
                            for (let k = 0; k < originalLen; k++) {
                                // we have a point or something, we need to advance the dimension by the length of this thing at the end
                                for (let dimOffset = 0; dimOffset < vecSize; dimOffset++) {
                                    // bounds check
                                    if (idx.data[j] < 0 || idx.data[j] >= shape[i]) {
                                        return [null, null, makeErr(ctx, `index ${idx.data[j]} in ${nodeText(ctx, errorNode)} was out of bounds`)];
                                    }
                                }
                                
                                for (let dimOffset = 0; dimOffset < vecSize; dimOffset++) {
                                    flatIndexes[j * originalLen + k] += strides[i + dimOffset] * idx.data[j * vecSize + dimOffset];
                                }
                            }
                        }

                        i += vecSize;
                    }

                } else {
                    return [null, null, makeErr(ctx, `tf kinda type is this huh: ${vtToString(idx.vt)}`)]
                }
            }

            return [flatIndexes, shape.slice(i), null];
        }

        function evaluateIndexation(ctx, x) {
            const expr = evaluateExpression(ctx, x.expr);
            if (expr.vt !== VT_TENSOR) {
                return makeErr(ctx, `the type ${vtToString(expr.vt)} cannot be indexed yet`);
            }
            const indexes = x.indexes.map((x) => evaluateExpression(ctx, x));

            const [flatIndices, remainingShape, err] = evaluateIndicesToFlatArray(ctx, x, expr.shape, indexes);
            if (err !== null) {
                return err;
            }


            if (remainingShape.length === 0) {
                for(let i = 0; i < flatIndices.length; i++) {
                    flatIndices[i] = expr.data[flatIndices[i]];
                }

                if (flatIndices.length === 1) {
                    return makeNumber(flatIndices[0])
                }

                return {
                    vt: VT_TENSOR,
                    shape: [flatIndices.length],
                    data: flatIndices,
                }
            }

            // note to self: this kind of code is FAR easier to write when in the zone than it is to read,
            // don't be discouraged if you don't understand a word of it. Kinda like regex actually
            const stride = remainingShape.reduce((a, b) => a * b, 1);
            const largerArray = Array(flatIndices.length * stride);
            for(let i = 0; i < flatIndices.length; i++) {
                for(let j = 0; j < stride; j++) {
                    largerArray[i * stride + j] = expr.data[flatIndices[i] + j];
                }
            }

            return {
                vt: VT_TENSOR,
                shape: [...remainingShape],
                data: largerArray
            };
        }

        // this does not push or pop any stack frames, they need to be done by the caller
        function evaluateBlock(ctx, x) {
            // it is a custom user defined function.
            // we will just return the final value it calculated.
            // (this could simply by a variable on it's own on a single line, so no problems here)
            let lastStatementResult = { vt: VT_NULL };

            // evaluate function
            for(let i = 0; i < x.body.length; i++) {
                lastStatementResult = evaluateExpression(ctx, x.body[i]);
            }

            return lastStatementResult;
        }

        function evaluateForLoop(ctx, x) {
            ctx.variables.pushStackFrame();

            // initialize loop
            for(let i = 0; i < x.initializers.length; i++) {
                evaluateExpression(ctx, x.initializers[i]);
            }

            let maxLoopCount = 1000000, safetyCounter = 0;

            // drive loop
            for(;
                safetyCounter < maxLoopCount && isTrue(evaluateExpression(ctx, x.loopCondition));
                safetyCounter++ // make sure we can't get any infinite loops even if we want to. I don't know how to allow users to break them yet
            ) {

                // loop body
                evaluateBlock(ctx, x.loopBody, false);

                // increment
                for(let i = 0; i < x.iterators.length; i++) {
                    evaluateExpression(ctx, x.iterators[i]);
                }
            }

            ctx.variables.popStackFrame();

            if (safetyCounter === maxLoopCount) {
                return makeErr(ctx, `you may have an infinite loop in your program - they are very easy to run into, which is why I have a limiter of 1,000,000 iterations per loop for now`);
            }

            return { vt: VT_NULL };
        }

        function evaluateString(x) {
            return makeString(x.text);
        }

        function evaluateExpression(ctx, x) {
            if (!x) {
                throw new Error("expression not defined");
            }

            const type = x.t;
            let value;

            switch (type) {
                case T_NUMBER:
                    value = evaluateNumber(x);
                    break;
                case T_STRING:
                    value = evaluateString(x);
                    break;
                case T_BLOCK:
                    ctx.variables.pushStackFrame();
                    value = evaluateBlock(ctx, x);
                    ctx.variables.popStackFrame();
                    break;
                case T_BUILTIN_CONSTANT:
                case T_IDENT:
                    value = evaluateVariable(ctx, x);
                    break;
                case T_EXPR_INDEXATION:
                    value = evaluateIndexation(ctx, x);
                    break;
                case T_EXPR:
                case T_TERM:
                case T_COMPARISON:
                    value = evaluateChain(ctx, x);
                    break;
                case T_UNARY_OP:
                    value = evaluateUnaryOp(ctx, x);
                    break;
                case T_FUNCTION_CALL:
                    value = evaluateFunctionCall(ctx, x);
                    break;
                case T_ASSIGNMENT:
                    value = evaluateAssignment(ctx, x);
                    break;
                case T_TERNARY:
                    value = evaluateTernary(ctx, x);
                    break;
                case T_TENSOR:
                    value = evaluateTensor(ctx, x);
                    break;
                case T_FOR_LOOP:
                    value = evaluateForLoop(ctx, x);
                    break;
                default:
                    value = makeErr(ctx, "Unknown ast node type: " + type);
                    break;
            }

            return value;
        }


        // a stack of hashmaps to keep track of scopes. 
        // the hashmaps are pooled, because that is probably more efficient than
        // appending and popping a new map from an array a thousand times
        class ScopeStack {
            constructor() {
                this.scopes = [new Map()];
                this.currentScope = 0;
            }
            pushStackFrame() {
                if (this.currentScope === this.scopes.length - 1) {
                    this.scopes.push(new Map());
                }

                this.currentScope++;
                this.scopes[this.currentScope].clear();
            }
            popStackFrame() {
                this.currentScope--;
            }
            has(key) {
                for(let i = this.currentScope; i >= 0; i--) {
                    if (this.scopes[i].has(key)) {
                        return true;
                    }
                }

                return false;
            }
            get(key) {
                for(let i = this.currentScope; i >= 0; i--) {
                    if (this.scopes[i].has(key)) {
                        return this.scopes[i].get(key);
                    }
                }

                return null;
            }
            set(ctx, key, value, isDeclaration) {
                // if declaration, create variable in local scope
                if (isDeclaration) {
                    const currentScope = this.scopes[this.currentScope];
                    if (currentScope.has(key)) 
                        return makeErr(ctx, `variable ${key} already defined, with value: ${valueToString(currentScope.get(key))}`);
                        
                    currentScope.set(key, value);
                    return null;
                } 
                
                // set variable in whatever scope it is in
                for (let i = this.currentScope; i >= 0; i--) {
                    if (!this.scopes[i].has(key)) continue;
                    
                    this.scopes[i].set(key, value);
                    return null;
                }

                return makeErr(ctx, `couldn't set ${key}, it wasn't found anywhere`);
            }
        }

        function evaluateProgram(program, text) {
            const ctx = {
                variables: new ScopeStack(),
                errors: [],
                text: text
            };

            if (program.error) {
                makeErr(ctx, program.error);
            }

            try {
                ctx.results = program.expressions.map((line) => {
                    let val = {
                        ...evaluateExpression(ctx, line)
                    };
    
                    val.show = line.show;
                    val.lineNumber = line.lineNumber;
                    return val;
                });
            } catch(err) {
                ctx.results = [
                    makeErr(ctx, `A Javascript error occurred while evaluating your program: ${err}`)
                ];
            }

            return ctx;
        }

        // not a particularly good visualisation. TODO: improve
        function tensorToString(t) {
            if (t.vt !== VT_TENSOR) {
                return valueToString(t);
            }

            let counter = 0;
            const dfs = (level) => {
                if (level === t.shape.length) {
                    let val = t.data[counter];
                    counter++;
                    return val;
                }

                let stringBuilder = [];
                for (let i = 0; i < t.shape[level]; i++) {
                    let str = dfs(level + 1);
                    if (i > 0) {
                        str = " " + str;
                    }
                    stringBuilder.push(str);
                }

                const joinStr = level === t.shape.length - 1 ? ", " : ", \n";
                return "[" + stringBuilder.join(joinStr) + "]";
            };

            let dataStr = dfs(0);

            return "shape: " + t.shape.join("x") + ", data: \n" + dataStr.replace(/\n/g, "\n\t");
        }

        function valueToString(v) {
            switch (v.vt) {
                case VT_TENSOR:
                    return tensorToString(v).replace("\n", "\n\t");
                case VT_NUMBER:
                    return v.val.toString();
                case VT_STRING:
                    return v.val;//"\"" + v.val.toString().replace(/"/g, "\\\"") + "\"";
                case VT_FUNCTION:
                    return v.text;
                default:
                    return `${v.val}`;
            }
        }

        function thingToString(v) {
            let type = vtToString(v.vt);
            let str = valueToString(v);

            return `[${type}] \n${str}`;
        }

        // ---- parser

        const T_EXPR = debug ? "T_EXPR" : 0;
        const T_NUMBER = debug ? "T_NUMBER" : 1;
        const T_OP_EXPR = debug ? "T_OP_EXPR" : 2;
        const T_OP_TERM = debug ? "T_OP_TERM" : 3;
        const T_TERM = debug ? "T_TERM" : 4;
        const T_BUILTIN_CONSTANT = debug ? "T_BUILTIN_CONSTANT" : 5;
        const T_UNARY_OP = debug ? "T_UNARY_OP" : 6;
        const T_IDENT = debug ? "T_IDENT" : 7; // arbitrary text, could be anything.
        const T_FUNCTION_CALL = debug ? "T_FUNCTION_CALL" : 8;
        const T_OP_EXPONENT = debug ? "T_OP_EXPONENT" : 9;
        const T_ASSIGNMENT = debug ? "T_ASSIGNMENT" : 10;
        const T_TERNARY = debug ? "T_TERNARY" : 11;
        const T_TENSOR = debug ? "T_TENSOR" : 12;
        const T_EXPR_INDEXATION = debug ? "T_EXPR_INDEXATION" : 13;
        const T_FOR_LOOP = debug ? "T_FOR_LOOP" : 14;
        const T_BLOCK = debug ? "T_BLOCK" : 15;
        const T_STRING = debug ? "T_STRING" : 16;
        const T_OP_COMPARISON = debug ? "T_OP_COMPARISON" : 17;
        const T_COMPARISON = debug ? "T_COMPARISON" : 18;

        const reservedKeywords = [
            "for"
        ];


        // Thankyou Trevor https://stackoverflow.com/questions/1496826/check-if-a-single-character-is-a-whitespace
        function isWhitespace(c) {
            return (
                c === " " ||
                c === "\n" ||
                c === "\t" ||
                c === "\r" ||
                c === "\f" ||
                c === "\v" ||
                c === "\u00a0" ||
                c === "\u1680" ||
                c === "\u2000" ||
                c === "\u200a" ||
                c === "\u2028" ||
                c === "\u2029" ||
                c === "\u202f" ||
                c === "\u205f" ||
                c === "\u3000" ||
                c === "\ufeff"
            );
        }

        function isDigit(c) {
            return (
                c === "1" ||
                c === "2" ||
                c === "3" ||
                c === "4" ||
                c === "5" ||
                c === "6" ||
                c === "7" ||
                c === "8" ||
                c === "9" ||
                c === "0"
            );
        }

        function isLetter(c) {
            return c.toUpperCase() != c.toLowerCase() || c.codePointAt(0) > 127;
        }

        // this code also parses comments.
        // This way, comments can appear almost anywhere in the
        function advanceWhileWhitespace(text, pos) {
            if (debug) {
                if (typeof text !== "string") {
                    throw new Error("you might be calling advanceWhileWhitespace wrong");
                }
            }

            while (
                pos < text.length &&
                (isWhitespace(text[pos]) || (text[pos] === "/" && text[pos + 1] === "/"))
            ) {
                // single line comment, ignore all text on the same line after //.
                // TODO: figure out how we can actually store these comments and use them
                // in a meaningful way
                if (text[pos] === "/") {
                    pos += 2;
                    while (pos < text.length && text[pos] !== "\n") {
                        pos++;
                    }
                }

                pos++;
            }
            return pos;
        }

        function hasText(text, pos, comp) {
            if (pos + comp.length > text.length) {
                return false;
            }

            return text.substring(pos, pos + comp.length) === comp;
        }

        // parses one of some array possible delimiters. oneOfWhat is an array of possible strings.
        // It is important that the delimiters are arranged in order of longest to shortest.
        // If you pass in ["<", "<="] and we have "<=" in the string, we won't get to it because we also have "<".
        function parseOneOf(text, ctx, lines, possibleDelimiters, type) {
            const pos = advanceWhileWhitespace(text, ctx.pos);
            ctx.pos = pos;

            for (let i in possibleDelimiters) {
                const end = pos + possibleDelimiters[i].length;
                if (!hasText(text, pos, possibleDelimiters[i])) {
                    continue;
                }

                ctx.pos = end;
                lines.push({
                    t: type,
                    start: pos,
                    end: end,
                    text: text.substring(pos, end)
                });
                return true;
            }

            return false;
        }

        function parseOpComparison(text, ctx, ops) {
            return parseOneOf(text, ctx, ops, [">=", "<=", "==", ">", "<"], T_OP_COMPARISON);
        }

        // operators with the same precedence as addition
        function parseOpExpr(text, ctx, ops) {
            return parseOneOf(text, ctx, ops, ["+", "-"], T_OP_EXPR);
        }

        // one of *, /, %
        function parseOpTerm(text, ctx, ops) {
            return parseOneOf(text, ctx, ops, ["**", "*", "/", "%", "^"], T_OP_TERM);
        }

        // one of ^
        function parseOpExponent(text, ctx, ops) {
            return parseOneOf(text, ctx, ops, ["^"], T_OP_EXPONENT);
        }

        // operators with the same precedence as multiplication
        function parseNumber(text, ctx, lines) {
            const start = advanceWhileWhitespace(text, ctx.pos);
            if (start >= text.length) {
                return false;
            }
            ctx.pos = start;

            if (!isDigit(text[ctx.pos])) return false;

            let foundDecimal = false;
            while (ctx.pos < text.length && (isDigit(text[ctx.pos]) || (!foundDecimal && text[ctx.pos] === "."))) {
                if (text[ctx.pos] === ".") {
                    foundDecimal = true;
                }

                ctx.pos++;
            }

            lines.push({
                t: T_NUMBER,
                start: start,
                end: ctx.pos,
                text: text.substring(start, ctx.pos)
            });
            return true;
        }

        // Parses a series of terms like <term> (<operator> <term>)*
        // the parsers for term and operator can be specified as functions
        function parseChain(text, ctx, lines, type, termParser, opParser) {
            let start = advanceWhileWhitespace(text, ctx.pos);
            if (start >= text.length) {
                return false;
            }

            const terms = [];
            const ops = [];

            if (!termParser(text, ctx, terms)) {
                return false;
            }

            while (opParser(text, ctx, ops)) {
                if (!termParser(text, ctx, terms)) {
                    // remove the last operator we parsed, we shouldn't have
                    const op = ops.pop();

                    // reset end
                    ctx.pos = terms[terms.length - 1].end;
                    break;
                }
            }

            if (terms.length === 1) {
                // unwraps a single term to be it's own thing.
                // the AST becomes unmanageably large if we don't unwrap nodes like this.
                // although performance might be better, it is mainly a debugging optimization
                lines.push(terms[0]);
            } else {
                lines.push({
                    t: type,
                    start: start,
                    end: ctx.pos,
                    text: text.substring(start, ctx.pos),
                    terms: terms,
                    ops: ops,
                    show: false,
                    lineNumber: 0
                });
            }

            return true;
        }

        function parseGroup(text, ctx, lines) {
            const start = advanceWhileWhitespace(text, ctx.pos);
            if (start >= text.length) {
                return false;
            }

            if (text[start] === "(") {
                ctx.pos = start + 1;
                if (parseExpressionTopLevel(text, ctx, lines)) {
                    ctx.pos = advanceWhileWhitespace(text, ctx.pos);
                    if (text[ctx.pos] === ")") {
                        lines[lines.length - 1].start = start;
                        lines[lines.length - 1].end++;
                        ctx.pos++;
                        return true;
                    }
                }
            }
            return false;
        }

        // also parses a tensor indexing op like x[1][1][1]
        function parseVariable(text, ctx, lines) {
            const start = ctx.pos;

            if (!parseIdentifier(text, ctx, lines)) return false;
            return true;
        }

        function parseUnaryOp(text, ctx, lines) {
            const start = advanceWhileWhitespace(text, ctx.pos);
            if (start >= text.length) {
                return false;
            }

            const op = [];
            const expr = [];

            ctx.pos = start;
            if (!parseOneOf(text, ctx, op, unaryOps, T_UNARY_OP)) {
                return false;
            }

            ctx.pos = advanceWhileWhitespace(text, ctx.pos);
            if (!parseExpressionTopLevel(text, ctx, expr)) {
                return false;
            }

            lines.push({
                t: T_UNARY_OP,
                start: start,
                end: ctx.pos,
                op: op[0],
                expr: expr[0]
            });
            return true;
        }

        function parseIdentifier(text, ctx, lines) {
            const start = advanceWhileWhitespace(text, ctx.pos);
            if (start >= text.length) {
                return false;
            }

            let pos = start;
            if (!isLetter(text[pos])) {
                return false;
            }
            pos++;

            while (pos < text.length && (isDigit(text[pos]) || isLetter(text[pos]))) {
                pos++;
            }

            ctx.pos = pos;

            const identText = text.substring(start, ctx.pos);
            if (reservedKeywords.includes(identText)) return false;

            lines.push({
                t: T_IDENT,
                start: start,
                end: ctx.pos,
                text: identText
            });

            return true;
        }

        // wrongly assumes there will always be at least one element in this list
        // also, hasTerminator only works when the terminator is length=1. we need to write it properly next time, or later
        function parseDelimitedList(text, ctx, lines, exprParser, hasDelimiter, hasTerminator, mustTerminate=true) {
            const start = advanceWhileWhitespace(text, ctx.pos);
            if (start >= text.length) {
                return false;
            }

            if (hasTerminator(text, ctx.pos)) {
                return true;
            }

            ctx.pos = start;
            let terminated = false;
            while (exprParser(text, ctx, lines)) {
                ctx.pos = advanceWhileWhitespace(text, ctx.pos);
                if (hasDelimiter(text, ctx.pos)) {
                    //text[nextStartPos] === delimiter
                    ctx.pos += 1;
                    continue;
                }

                if (hasTerminator(text, ctx.pos)) {
                    // text[nextStartPos] === terminator
                    terminated = true;
                    break;
                }

                return false;
            }

            if (mustTerminate && !terminated) {
                // allow for things like [1,2,] (trailing comma)
                ctx.pos = advanceWhileWhitespace(text, ctx.pos);
                if (!hasTerminator(text, ctx.pos)) {
                    return false;
                }
            }

            return true;
        }

        function parseFunctionCall(text, ctx, lines) {
            const start = advanceWhileWhitespace(text, ctx.pos);
            if (start >= text.length) {
                return false;
            }

            const name = [];
            const args = [];

            ctx.pos = start;
            if (!parseIdentifier(text, ctx, name)) {
                return false;
            }

            if (text[ctx.pos] != "(") {
                return false;
            }
            ctx.pos++;

            const argsStartPos = advanceWhileWhitespace(text, ctx.pos);

            ctx.pos = argsStartPos;
            if (
                !parseDelimitedList(
                    text,
                    ctx,
                    args,
                    parseExpressionTopLevel,
                    (t, pos) => hasText(t, pos, ","),
                    (t, pos) => hasText(t, pos, ")")
                )
            ) {
                return false;
            }

            ctx.pos += 1;

            lines.push({
                t: T_FUNCTION_CALL,
                start: start,
                end: ctx.pos,
                name: name[0],
                args: args
            });

            return true;
        }

        // it assumes the starting pos already has a digit. don't call it otherwise
        function parseIntInline(text, ctx) {
            const start = ctx.pos;
            while (ctx.pos < text.length && isDigit(text[ctx.pos])) {
                ctx.pos++;
            }

            return parseInt(text.substring(start, ctx.pos));
        }

        // surprisingly complicated
        function parseTensor(text, ctx, lines) {
            const start = advanceWhileWhitespace(text, ctx.pos);
            if (start >= text.length) {
                return false;
            }

            const shape = [];

            if (text[start] !== "[") {
                return false;
            }

            ctx.pos += 1;
            const rows = [];
            // probably more optimal to only be parsing tensors or numbers here.
            if (
                !parseDelimitedList(
                    text,
                    ctx,
                    rows,
                    parseExpressionTopLevel,
                    (t, pos) => hasText(t, pos, ","),
                    (t, pos) => hasText(t, pos, "]")
                )
            ) {
                return false;
            }
            ctx.pos += 1;

            // we need to figure out the shape, and evaluate the inline expressions later in the evaluation step
            lines.push({
                t: T_TENSOR,
                start: start,
                end: ctx.pos,
                rows: rows,
                evaluated: false
            });
            return true;
        }

        // parses a time like 4:20 into a number representing the number of minutes since the start of the day.
        // useful for common duration calculations that I would use a calculator for
        function parseHmTime(text, ctx, lines) {
            const start = advanceWhileWhitespace(text, ctx.pos);
            if (start >= text.length) {
                return false;
            }
            ctx.pos = start;

            let h = 0, m = 0;

            if (!isDigit(text[ctx.pos])) return false;

            h = parseIntInline(text, ctx);

            ctx.pos = advanceWhileWhitespace(text, ctx.pos);

            if (text[ctx.pos] !== ":") return false;
            ctx.pos++;

            if (!isDigit(text[ctx.pos])) return false;

            const mTemp = []
            if (!parseNumber(text, ctx, mTemp)) return false; 
            m = evaluateNumber(mTemp[0]).val;
            
            ctx.pos = advanceWhileWhitespace(text, ctx.pos);
            if (hasText(text, ctx.pos, "am") || hasText(text, ctx.pos, "AM")) {
                ctx.pos += 2;
            } else if (hasText(text, ctx.pos, "pm") || hasText(text, ctx.pos, "PM")) {
                if(h < 12) {
                    h += 12;
                }
                ctx.pos += 2;
            }

            lines.push({
                t: T_NUMBER,
                start: start,
                end: ctx.pos,
                text: (h * 60 + m).toString()
            });
            return true;
        }

        function parseString(text, ctx, lines) {
            const start = advanceWhileWhitespace(text, ctx.pos);
            if (start >= text.length) {
                return false;
            }

            if (text[ctx.pos] !== "\"") return false;
            ctx.pos++;

            while(
                ctx.pos < text.length &&
                (text[ctx.pos] !== "\"" || (
                    text[ctx.pos] === "\"" && text[ctx.pos-1] === "\\"
                ))
            ) {
                ctx.pos++;
            }

            if (text[ctx.pos] !== "\"") return false;
            ctx.pos++;

            lines.push({
                t: T_STRING,
                start: start,
                end: ctx.pos,
                text: text.substring(start + 1, ctx.pos - 1).replace(/\\"/g, "\"")
            });
            return true;
        }

        // note that the ordering matters
        function parseThing(text, ctx, lines) {
            const start = advanceWhileWhitespace(text, ctx.pos);
            if (start >= text.length) {
                return false;
            }

            ctx.pos = start;
            if (parseBlock(text, ctx, lines)) return true;

            ctx.pos = start;
            if (parseGroup(text, ctx, lines)) return true;

            ctx.pos = start;
            if (parseUnaryOp(text, ctx, lines)) return true;

            ctx.pos = start;
            if (parseFunctionCall(text, ctx, lines)) return true;

            // important that this is after parseFunctionCall and what have you, the function name will be confused for a variable otherwise
            ctx.pos = start;
            if (parseVariable(text, ctx, lines)) return true;

            // primitives

            ctx.pos = start;
            if (parseHmTime(text, ctx, lines)) return true;

            ctx.pos = start;
            if (parseNumber(text, ctx, lines)) return true;

            ctx.pos = start;
            if (parseTensor(text, ctx, lines)) return true;

            ctx.pos = start;
            if (parseString(text, ctx, lines)) return true;

            return false;
        }

        function parseExponent(text, ctx, lines) {
            return parseChain(text, ctx, lines, T_TERM, parseThing, parseOpExponent);
        }

        function parseTerm(text, ctx, lines) {
            return parseChain(text, ctx, lines, T_TERM, parseExponent, parseOpTerm);
        }

        function parseExpression(text, ctx, lines) {
            return parseChain(text, ctx, lines, T_EXPR, parseTerm, parseOpExpr);
        }

        function parseComparison(text, ctx, lines) {
            return parseChain(text, ctx, lines, T_COMPARISON, parseExpression, parseOpComparison);
        }

        function parseIndexation(text, ctx, indexes) {
            if (text[ctx.pos] !== "[") {
                return false;
            }

            while (hasText(text, ctx.pos, "[")) {
                ctx.pos = advanceWhileWhitespace(text, ctx.pos + 1);

                if (!parseExpressionTopLevel(text, ctx, indexes)) return false;

                ctx.pos = advanceWhileWhitespace(text, ctx.pos);
                if (!text[ctx.pos] === "]") {
                    return false;
                }
                ctx.pos = advanceWhileWhitespace(text, ctx.pos + 1);
            }

            return true;
        }

        // consider having a new T_BLOCK or something
        function parseBlock(text, ctx, lines) {
            const body = [];

            ctx.pos = advanceWhileWhitespace(text, ctx.pos);
            if (ctx.pos >= text.length) {
                return false;
            }

            if (!hasText(text, ctx.pos, "{")) return false;
            ctx.pos = advanceWhileWhitespace(text, ctx.pos + 1);

            if (!hasText(text, ctx.pos, "}")) {
                if (!parseExpressionList(text, ctx, body)) return false;
                ctx.pos = advanceWhileWhitespace(text, ctx.pos);
            }

            if (!hasText(text, ctx.pos, "}")) {
                return false;
            }
            
            ctx.pos += 1;
            lines.push({
                t: T_BLOCK,
                body: body
            })
            return true;
        }

        function parseForLoop(text, ctx, lines) {
            const start = advanceWhileWhitespace(text, ctx.pos);
            if (start >= text.length ) {
                return false;
            }

            if (!hasText(text, ctx.pos, "for")) return false;

            ctx.pos = advanceWhileWhitespace(text, ctx.pos+3);

            const initializers = [];
            const loopCondition = [];
            const iterators = [];
            const loopBody = [];

            // parse initializers
            if (!parseDelimitedList(
                text, ctx, initializers, parseAssignment, 
                (t, pos) => hasText(t, pos, ","),
                (t, pos) => hasText(t, pos, ";"),
                false
            )) {
                return false;
            }
            ctx.pos = advanceWhileWhitespace(text, ctx.pos+1);

            // parse loop condition expression
            if (!parseExpressionTopLevel(text, ctx, loopCondition)) return false;
            ctx.pos = advanceWhileWhitespace(text, ctx.pos);

            if (!hasText(text, ctx.pos, ";")) return false;
            ctx.pos = advanceWhileWhitespace(text, ctx.pos+1);

            // parse loop iterators
            if (!parseDelimitedList(
                text, ctx, iterators, parseAssignment, 
                (t, pos) => hasText(t, pos, ","),
                (t, pos) => hasText(t, pos, "{")
            )) {
                return false;
            }

            // parse loop body
            if (!parseBlock(text, ctx, loopBody)){
                return false;
            }

            lines.push({
                t: T_FOR_LOOP,
                start: start,
                end: ctx.pos,
                initializers: initializers,
                loopCondition: loopCondition[0],
                iterators: iterators,
                loopBody: loopBody[0]
            });
            return true;
        }

        function parseExpressionTopLevel(text, ctx, lines) {
            const start = advanceWhileWhitespace(text, ctx.pos);
            if (start >= text.length ) {
                return false;
            }

            // TODO: try moving to root level as thing
            ctx.pos = start;
            if (parseForLoop(text, ctx, lines)) return true;

            // parse an expression. the ternary is the top-level of an expression.
            ctx.pos = start;
            if (!parseTernary(text, ctx, lines)) return false;

            const indexes = [];
            ctx.pos = advanceWhileWhitespace(text, ctx.pos);
            if (!parseIndexation(text, ctx, indexes)) return true;

            lines[lines.length - 1] = {
                t: T_EXPR_INDEXATION,
                start: start,
                end: ctx.pos,
                expr: lines[lines.length - 1],
                indexes: indexes
            };
            return true;
        }

        function parseTernary(text, ctx, lines) {
            const expr = [];
            if (!parseComparison(text, ctx, expr)) return false;

            const ternaryStart = advanceWhileWhitespace(text, ctx.pos);
            ctx.pos = ternaryStart;
            if (text[ctx.pos] !== "?") {
                // we only got an expression, that is fine
                lines.push(expr[0]);
                return true;
            }

            ctx.pos = advanceWhileWhitespace(text, ctx.pos + 1);

            if (!parseComparison(text, ctx, expr)) return false;

            ctx.pos = advanceWhileWhitespace(text, ctx.pos);
            if (text[ctx.pos] !== ":") {
                // we only got one branch of the ternary, that isn't enough
                return false;
            }

            // the next part can also be a ternary, i.e
            // x := y < 0 ? 2 : y > 3 ? 3 : 0

            ctx.pos = advanceWhileWhitespace(text, ctx.pos + 1);
            if (!parseTernary(text, ctx, expr)) {
                // we weren't able to parse the second branch of the ternary
                return false;
            }

            lines.push({
                t: T_TERNARY,
                start: ternaryStart,
                end: ctx.pos,
                conditional: expr[0],
                ifTrue: expr[1],
                else: expr[2]
            });
            return true;
        }

        function parseAssignment(text, ctx, lines) {
            const start = advanceWhileWhitespace(text, ctx.pos);
            if (start >= text.length) {
                return false;
            }

            const lhs = [];
            const rhs = [];
            if (!parseExpressionTopLevel(text, ctx, lhs)) return false;

            const assignOpPos = advanceWhileWhitespace(text, ctx.pos);

            let isDeclaration = false;
            if (hasText(text, assignOpPos, "=")) {
                ctx.pos = assignOpPos + 1;
            } else if (hasText(text, assignOpPos, ":=")) {
                ctx.pos = assignOpPos + 2;
                isDeclaration = true;
            } else {
                // it isn't an assignment. we are just unwrapping
                lines.push(lhs[0]);
                return true;
            }

            if (!parseExpressionTopLevel(text, ctx, rhs)) {
                return false;
            } 

            lines.push({
                t: T_ASSIGNMENT,
                start: start,
                end: ctx.pos,
                lhs: lhs[0],
                rhs: rhs[0],
                isDeclaration: isDeclaration
            });
            return true;
        }

        function parseExpressionList(text, ctx, list) {
            const start = ctx.pos;

            while (parseAssignment(text, ctx, list)) {
                const endsWithSemicolon = text[ctx.pos] === ";";

                const lastAdded = list[list.length - 1];
                lastAdded.show = !endsWithSemicolon;
                lastAdded.lineNumber = text.substring(0, lastAdded.start).split("\n").length - 1;

                if (endsWithSemicolon) {
                    ctx.pos++;
                }
            }

            return start !== ctx.pos;
        }

        // return an AST-like thing
        function parseProgram(text) {
            const ctx = { pos: 0 };
            const lines = [];

            // this used to be a while loop, we may need to fix a bug here. if not, delete this comment
            parseExpressionList(text, ctx, lines);
            ctx.pos = advanceWhileWhitespace(text, ctx.pos);

            const root = {
                expressions: lines,
                error: null
            };

            if (ctx.pos !== text.length) {
                const lines = text.substring(0, ctx.pos).split("\n");
                const linePos = ctx.pos - lines.lastIndexOf("\n");
                let contextText = text.substring(ctx.pos);
                if (contextText.length > 50) {
                    contextText = contextText.substring(0, 50) + "...";
                }
                root.error = `Couldn't read line ${lines.length} pos ${linePos}: "${contextText}"`;
            }

            return root;
        }

        function debugFormatAST(ast, text) {
            const dfs = (node) => {
                if (typeof node === "string") {
                    return;
                }

                if (node === null || node === undefined) {
                    return "undefined";
                }

                if (typeof node.start === "number" && typeof node.end === "number") {
                    // node.val = evaluateProgram(node.text);
                    delete node.start;
                    delete node.end;
                }

                const limit = 10;
                if (
                    typeof node.length === "number" &&
                    node.length > limit &&
                    node.push !== undefined &&
                    node.splice !== undefined
                ) {
                    let originalLength = node.length;
                    node.splice(limit, node.length - limit);
                    node.push(
                        "and " +
                            (originalLength - limit) +
                            " more items that have been hidden for performance reasons"
                    );
                }

                for (const k of Object.keys(node)) {
                    dfs(node[k]);
                }
            };

            dfs(ast);
            return ast;
        }

        // ---- actual website code

        const input = document.getElementById("input");
        const showAstCheckbox = document.getElementById("show-ast-checkbox");
        const showResultCheckbox = document.getElementById("show-result-checkbox");
        const showAllTestcasesCheckbox = document.getElementById("show-all-tests");
        const showAstOutput = document.getElementById("ast-output");
        const showResultOutput = document.getElementById("result-output");
        const testcaseContainer = document.getElementById("testcases");

        // HTML doesn't like tabs, we need this additional code to be able to insert tabs.
        input.addEventListener("keydown", (e) => {
            if (e.keyCode !== 9) return;

            e.preventDefault();

            var start = input.selectionStart;
            var end = input.selectionEnd;

            // set textarea value to: text before caret + tab + text after caret
            input.value = input.value.substring(0, start) + "\t" + input.value.substring(end);

            // put caret at right position again
            input.selectionStart = input.selectionEnd = start + 1;

            onInputChange();
        });

        const onInputChange = () => {
            rerender();
        };

        input.addEventListener("input", onInputChange);

        showAstCheckbox.addEventListener("change", () => rerender());
        showResultCheckbox.addEventListener("change", () => rerender());
        showAllTestcasesCheckbox.addEventListener("change", () => rerenderTests());

        function rerender() {
            // line numbers.
            document.getElementById("line-numbers").innerText = [
                ...Array(input.value.split("\n").length).keys()
            ].join("\n");

            // debug outputs

            if (showAstCheckbox.checked) {
                showAstOutput.removeAttribute("hidden");
            } else {
                showAstOutput.setAttribute("hidden", true);
            }

            if (showResultCheckbox.checked) {
                showResultOutput.removeAttribute("hidden");
            } else {
                showResultOutput.setAttribute("hidden", true);
            }

            // compile and interpret code

            const text = input.value;
            const ast = parseProgram(text);
            const result = evaluateProgram(ast, text);

            const getClass = (v) => {
                if (v.vt == VT_ERROR) {
                    return "error";
                }

                return "";
            };

            let resultsTextOutput = [];

            // // code to align results with the line the expression appeared on.
            // if (result.results.length > 0) {
            //     let currentResultIndex = 0;
            //     for(let ln = 0; ln <= result.results[result.results.length - 1].lineNumber; ln++) {
            //         const v = result.results[currentResultIndex];
            //         if (v.lineNumber === ln) {
            //             resultsTextOutput.push(v.show ? `[${vtToString(v.vt)}]: ${v.val}` : "");
            //             currentResultIndex++;
            //             console.log(currentResultIndex)
            //         } else {
            //             console.log(currentResultIndex)
            //             resultsTextOutput.push("");
            //         }
            //     }
            // }
            const lastResult = result.results[result.results.length - 1];
            resultsTextOutput = lastResult?.show ? thingToString(lastResult) : "";

            const errorsTextOutput =
                result.errors.length === 0
                    ? ""
                    : `<pre>Last ${result.errors.length} errors:</pre>` +
                      result.errors
                          .map((v) => {
                              return `<pre class="error">${thingToString(v)}</pre>`;
                          })
                          .join("");

            // print result(s)
            document.getElementById("output").innerHTML =
                errorsTextOutput.length > 0 ? errorsTextOutput : resultsTextOutput;

            // debug output

            showAstOutput.innerText = JSON.stringify(debugFormatAST(ast, text), null, 4);
            showResultOutput.innerText = JSON.stringify(result, null, 4);
        }


        // ---- add testcases,

        const testcases = [
            {
                name: "typical math expression",
                input: "1 + 2 * 3 + 4^(sin(PI/2)*2)",
                expected: "23",
                alwaysShow: true,
            },
            {
                name: "logical comparisons",
                input: "((1 + 2 + 3 >= 1 + 2 + 3) == (1 + 2 + 3 > 1 + 2 + 3)) == 0",
                expected: "1",
                alwaysShow: true
            },
            {
                name: "matrix multiplication",
                input:`
A := I(4);

v := [1,2,3,4]

A ** v`,
                expected: "shape: 1x4, data: [[1,  2,  3,  4]]",
                alwaysShow: true
            },
            {
                name: "matrix transpose",
                input: `
A:= [[1,  2,  3], 
	 [1,  2,  3], 
	 [2,  4,  6]]
~A
`,

                expected: `shape: 3x3, data: 	[[1,  1,  2], 	 [2,  2,  4], 	 [3,  3,  6]]`,
                alwaysShow: true,
            },
            {
                name: "programming constructs - variable assignment",
                input: `
// anything after // on a line is ignored.
// the := operator makes a new variable:
x := 1

// the = operator assigns to an existing variable:
x = 2

// this distinction makes more sense when we have multiple scopes. 
i := -42
for i := 0; i < 3; i=i+1 {
    // the i here is different from the i out there
}

// (it should still be -42)
i
`,
                expected: "-42",
                alwaysShow: true,
            },
            {
                name: "programming constructs - blocks",
                input: `
// blocks are a list of expressions within curly braces {}.
// entire blocks are treated as expressions that are equal to the last line of the block
x := 2 * {
	y := 0;
    for i := 0; i < 10; i = i+1 {
        y = y + i
    }
    y
};

x

`,  
                expected: "90",
                alwaysShow: true,
            },
            {
                name: "programming constructs - functions",
                input: `
// functions are defined as follows:

f(x) := x^2

// functions can call other functions or even themselves.
// functions can accept anything as arguments, including other functions.

g(y, func) := 2 * func(y)

g(2, f)
`,
                expected: "8",
                alwaysShow: true
            },
            {
                name: "function test",
                input: "fib(x) := x <= 1 ? 1 : fib(x - 1) + fib(x-2)\n\nfib(10)",
                expected: "89",
                alwaysShow: true
            },
            {
                name: "identity matrix for loop",
                input: "x := T(10, 10);\nfor i:=0; i < 10; i = i+1 {\n\tx[i][i]=1\n}\n\nx", 
                expected: "shape: 10x10, data:[[1, 0, 0, 0, 0, 0, 0, 0, 0, 0],[0, 1, 0, 0, 0, 0, 0, 0, 0, 0],[0, 0, 1, 0, 0, 0, 0, 0, 0, 0],[0, 0, 0, 1, 0, 0, 0, 0, 0, 0],[0, 0, 0, 0, 1, 0, 0, 0, 0, 0],[0, 0, 0, 0, 0, 1, 0, 0, 0, 0],[0, 0, 0, 0, 0, 0, 1, 0, 0, 0],[0, 0, 0, 0, 0, 0, 0, 1, 0, 0],[0, 0, 0, 0, 0, 0, 0, 0, 1, 0],[0, 0, 0, 0, 0, 0, 0, 0, 0, 1]]"
            },
            {
                name: "for loop local scope",
                input:"x := 0;\nfor i := 0; i < 5; i=i+1 { x = x + 1; }\nfor i := 0; i < 5; i=i+1 { x = x + 1; }\nx", 
                expected: "10"
            },
            {
                name: "for loop",
                input:"x := 0;\nfor i := 0; i < 5; i=i+1 { x = x + 1; }\nx", 
                expected: "5"
            },
            {
                name: "basic indexing",
                input: "x := [[1,2,3], [4,5,6]]; x[1][0]",
                expected: "4"
            },
            {
                name: "identity matrix",
                input: "x := T(3,3); x[[[0,0],[1,1],[2,2]]] = [1,1,1]; x",
                expected: `	shape: 3x3, data: [[1, 0, 0], [0, 1, 0], [0, 0, 1]]`
            },
            {
                name: "test assigning to index",
                input: "x := [1,2,3]; x[0]=2; x\nx = T(2,3); x[0] = [1,2,3]; x",
                expected: `	shape: 2x3, data: [[1, 2, 3], [0, 0, 0]]`
            },
            {
                name: "indexing test 2",
                input: "[[1,2,3],[4,5,6]][0]",
                expected: "	shape: 3, data: [1, 2, 3]"
            },
            {
                name: "indexing with fewer dimensions should return tensor",
                input: "[[[1,2,3],[4,5,6]], [[4,4,4],[4,5,6]]][[0, 1]]",
                expected: "	shape: 2x3, data: [[1, 2, 3], [4, 5, 6]]"
            },
            {
                name: "order of operations",
                input: `1 * 2 + 3 * 2^2`,
                expected: "14"
            },
            {
                name: "brackets",
                input: `2^(1+1) + (2 * 3)`,
                expected: "10"
            },
            {
                name: "variables",
                input: `x := 3;
y := 33 * x;
x = y * x + x`,
                expected: "300"
            },
            {
                name: "assignment error",
                input: `y := 3; y := 3`,
                expected: "variable y already defined, with value: 3"
            },
            {
                name: "builtin math functions",
                input: "sin(PI) + cos(PI)",
                expected: "-0.9999999999999999"
            },
            {
                name: "Function wrong input type error",
                input: "sin(x)",
                expected: "Argument 0 to function sin was of type ERROR, but it wants NUMBER "
            },
            {
                name: "line comments",
                input: "x := // 324234 * sin(x)\n3; x",
                expected: "3"
            },
            {
                name: "ternary",
                input: "0 ? 100 : 2^2",
                expected: "4"
            },
            {
                name: "inline tensor",
                input: "[[1, 2, 3], [1, 2, 3]]",
                expected: "shape: 2x3, data: [[1, 2, 3], [1, 2, 3]] "
            },
            {
                name: "tensor func",
                input: "T(10, 10)",
                expected: "	shape: 10x10, data: [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]"
            }
        ];

        function truncate(t, len) {
            if (t.length > len) {
                return t.substring(0, len) + "...";
            }

            return t;
        }

        function rerenderTests() {
            const onlyShowInteresting = !showAllTestcasesCheckbox.checked;
            let passes = 0, fails = 0;

            let tests = testcases
                    .filter((testcase) => onlyShowInteresting ? testcase.alwaysShow : true);

            let testcaseTableHTML =
            `
                <tr><th>Input</th><th>Output</th></tr>
            ` +
                tests.map((testcase, i) => {
                        let output = "", isPassing = false;

                        try {
                            const text = testcase.input;
                            const ast = parseProgram(text);
                            const results = evaluateProgram(ast, text).results;
                            output = valueToString(results[results.length - 1]);
                            isPassing = testcase.expected.replace(/\s/g, "") === output.replace(/\s/g, "");
                        } catch(e) {
                            output = "Exception";
                            isPassing = false;
                        }

                        if(isPassing){
                            passes++;
                        } else {
                            fails++;
                        }

                        return `
                            <tr>
                                <td class="testcase-button" data-testcase-id="${i}">
                                    <h4>${testcase.name}</h4>
                                    <p>
                                        ${testcase.input}
                                    </p>
                                </td>
                                <td class="${isPassing ? "passing" : "failing"}" title="${isPassing ? "this testcase is passing" : "this testcase is failing"}">
                                    ${
                                        isPassing ? truncate(output, 70) : `
                                            <h4>Got:</h4>
                                            <p>
                                                ${output}
                                            </p>
                                            <h4>Expected:</h4>
                                            <p>
                                                ${testcase.expected}
                                            </p>
                                        `
                                    }
                                </td>
                            </tr>`;
                    })
                    .join("\n");

            if(!onlyShowInteresting) {
                testcaseTableHTML = `
                    <p>
                        Passing: ${passes}, Failing: ${fails};
                    </p>
                ` 
                    + testcaseTableHTML;
            }

            testcaseContainer.innerHTML = testcaseTableHTML;
            for (let id = 0; id < tests.length; id++) {
                const button = testcaseContainer.querySelector(`.testcase-button[data-testcase-id="${id}"]`);
                button.addEventListener("click", (e) => {
                    window.scrollTo(0, 0);
                    input.value = tests[parseInt(button.getAttribute("data-testcase-id"))].input.trim();
                    rerender();
                });
            }
        }

        // ---- set value
        input.value = `
A := [[1,  2,  3], 
	 [4,  5,  6]];

A ** [1,0, 0]
`;
        rerender();
        rerenderTests();


        // ---- zen mode

        const zenMode = document.getElementById("zen-mode");
        zenMode.addEventListener("click", () => {
            document.querySelectorAll(".not-zen").forEach((el) => {
                el.setAttribute("hidden", true);
            });
        });

        document.addEventListener("keydown", (e) => {
            if (e.key === "Escape") {
                document.querySelectorAll(".not-zen").forEach((el) => {
                    el.removeAttribute("hidden", true);
                });
            }
        });

        // ---- end
    </script>
</html>
